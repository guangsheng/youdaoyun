1, UDT User defined Type
    ADT Abstract defined Type
2, 就C++而言，struct和class除了"默认地成员访问权限"这一点不同外，没有任何区别。即只要你明确地声明每一个成员地访问权限，那么完全可以用struct取代class。
3，如果struct或class中存在数组成员，则把struct或class当作参数传递给函数时，默认为值传递，其中地数组将全部拷贝到函数堆栈中。
4，C++和C都支持相同类型对象之间的直接赋值操作，但不支持大小比较和判等。
5，位域
struct DateTime
{
    unsigned int year;
    unsigned int month      :4
    unsigned int                 :4
    unsigned int day          :2
    unsigned int                 :0
}
C语言的位域成员必须是int、unsigned int、signed int等类型。
可以定义非具名的位域成员，其作用相当于是占位符。
可以定义长度为0的位域成员，其作用是迫使下一个成员从下一个完整的机器字开始分配空间。
6，字节是编址的最小单位而不是位。
7，struct 成语对齐
1）任何时候都应该用sizeof()运算符来计算一个类或对象的大小，而不要自己猜测。
2）对于复合类型的对象，如果它的起始地址能够满足其中要求最严格的那个数据成员的自然对齐要求，那么他就是自然对齐的。
3）节省空间的方法：按照从大到小的顺序从前往后依次声明每一个数据成员，并且尽量使用较小的成员对齐方式。
4）如何获取任意复合类型中的每个数据成员的偏移字节数：使用offsetof宏。这个宏专门用来计算数据成员相对于对象起始地址的真实偏移量。它会把所有隐含成员也计算进去。
5）
enum Color { Red,BLUE}
struct Sedan
{
    bool m_hasSkylight;
    Color m_color;
    bool m_isAutoShift;
    double m_price;
    unsigned char m_seatNum;
}
这个占用40个字节，m_seatNum后面还需要7个字节的填充，因为需要满足Sedan对象数组的对齐要求。
struct Sedan
{
    double m_price;
    Cloor m_color;
    bool m_hakSkylight;
    bool m_isAutoShift;
    unsigned char m_seatNum;
}
这个占用16个字节
6）使用匿名枚举来定义程序中经常出现的常量集合是一个好主意，他可以取代宏常量和const符号常量。



