### 概念
- Go语言里的并发指的是让某一个函数独立于其他函数运行的能力
- Go并发模型：CSP（通信顺序进程，Communicating Sequential Processes）
- CSP是一种消息通信模型，通过在gorouting直接传递数据来传递消息，而不是对数据进行加锁来实现同步访问。

#### 并发与并行
- 操作系统会在物理处理器上调度线程运行，Go语言的运行时会在逻辑处理器上调度gorouting来运行。
- 在Go 1.5及以上版本，GO语言运行时默认会为每个可用的物理处理器分配一个逻辑处理器，在之前版本，整个应用程序只分配一个逻辑处理器。
- 并发（concurrency）不是并行（parallelism）。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情。而并发是指同时管理很多事情。这些事情可能只做到一半就被暂停去做别的事情了。就比如我们工作时，同时做很多事情，是并发而不是并行。
- **那么并发有什么好处**：和我们工作时同时做很多事情的好处是一样的，且计算机切换工作效率还更高。例如在Go中，正在运行的goroutine需要执行一个阻塞的系统调用，比如打开一个文件，当这类调用发生时，线程和goroutine会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回，与此同时，这个逻辑处理器就丢失了用来运行的线程，所以，调度器会新创建一个线程，并将其绑定到逻辑处理器上。之后，调度器会从本地运行队列中选择另一个goroutine来运行，一旦被阻塞的系统调用执行完成并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便后续调用。


### 技巧和易错点 
- 使用如下方法编译，可以检查出哪些代码在并发竞争性方面存在问题  
`go build -race` //用竞争检测器标识来编译程序
- 每个goroutine都会覆盖另一个goroutine的工作，这种工作发生在goroutine切换时。这个存在一个潜在的风险，如果切换时，被覆盖的goroutine中相关的共享变量已经被赋值或操作了，再次切换回操作这个goroutine时，相关的共享变量值会保持切换前的状态，但这个并不一定时程序员所期待的行为。
- 原子函数：当goroutine试图去调用任何原子函数时，这些goroutine都会自动根据所引用的变量做同步处理

### 库
#### runtime
- `runtime.GOMAXPROCS(runtime.NumCPU)`  修改逻辑处理器数量，给每个可用的核心分配一个逻辑处理器
- `runtime.Gosched`  是当前goroutine从线程退出，并放回到队列

#### sync
- `var wg sync.WaitGroup`  一个计数信号量，goroutine之间配合时常用
- `wg.Add(num)`  增加计数，计数为0时，wg.Wait()才会返回
- `wg.Done`  计数减一
- `wg.Wait()`  等待计数减为0
- 几个原子函数 sync/automic  
```AddInt64, LoadInt4, StoreInt64```

### 互斥锁实例
```
mutex.Lock()
		{
			// Capture the value of counter.
			value := counter

			// Yield the thread and be placed back in queue.
			runtime.Gosched()

			// Increment our local value of counter.
			value++

			// Store the value back into counter.
			counter = value
		}
		mutex.Unlock()
```

### 通道
#### 概念
- 当一个资源需要在goroutine之间共享时，通道在goroutine之间架起了一条管道，并提供了确保同步交换数据的机制。
- 声明通道时需要指定将要被共享的数据的数据类型。
- 可以通过通道共享的类型：内置类型、命名类型、结构类型和引用类型的值或指针。

#### 代码示例
- 创建通道  
```unbuffered := make(chan int)``` 无缓冲的整形通道  
```buffered := make(chan string, 10)``` 有缓冲的字符串通道
- 向通道发送值  
```buffered <- "Hello"```
- 从通道接受值  
```value := <-buffered```  
```value, ok := <-count```  无缓冲通道，ok为false，表示通道已经被关闭  
```value, ok := <-buffered``` 有缓冲通道，ok为false，表示通道已经空了，并且通道被关闭了
#### 无缓冲的通道
- 在接收前没有能力保存任何值的通道。
- 这种类型的通道要求发送方和接收方同时准备好，才能完成发送和接收操作。如果没有同时准备好，通道会导致先执行的一方阻塞等待。

#### 有缓冲的通道
- 在被接收前能存储一个或多个值得通道。
- 只有在通道中没有要接收的值时，接收动作才会被阻塞。
- 如果有多个goroutine从通道中取值，任何一个值被任何一个goroutine取走后，这个值就不在通道里了，也就是通道中的一个值只会被某一个goroutine取走。
