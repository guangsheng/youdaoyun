### 总体说明
1. Go是静态类型语言，也就意味着编译器需要在编译时知晓程序里每个值得类型。



### 用户定义的类型（类似C语言中struct）
#### 实例
```
type user struct{
    name  string
    ext   int
    privileged bool
}
```
**和C语言的区别：名字在前，关键字在后**
#### 基于一个已有的类型，将其创建为新的类型
```type Duration int64```  
**和C语言的区别：Go不认为Duration和int64是同一种类型，例如下面这段代码换编译时会报错**
```
var dur Duration
dur = int64(100)
```

### 方法
#### 定义
- 方法是类型的函数，用于给用户定义的类型添加新的行为
- 实际上也是函数，只是在声明时，在关键字func和方法名之间增加了一个参数（接收者）  

#### 接收者
- 简单理解，方法属于接收者。
- 接收者分为两类：值接收者（使用值得一个**副本**来执行）和指针接收者
- 当调用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值。
- Go语言即允许使用值，也允许使用指针来调用方法，不必严格符合接收者的类型。

##### 如何选择方法的接收者类型
- 如果给这个类型增加或删除某个值，是要创建一个新值还是更改当前的值，创建新值，使用值接收者，更改当前值，使用指针接收者。
- 是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定。这个决策应该是基于该类型的本质。这个规则的一个例外是，需要让类性值符合某个接口的时候，即便类型的本质是非原始本质的，也可以选择使用值接收者声明方法。

#### 引用类型
- 切片、映射、通道、接口和函数类型
- 对于引用类型，创建的变量被称作标头（header）值。每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据结构。

### 接口
#### 概念
- 多态是指代码可以根据类型的具体实现采取不同行为的能力。
- 对于Go，如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。
- Go没有明确的继承语法。对于Go，一切都是接口（用接口实现所有继承才能完成的功能）
- 实现了一个接口的所有函数，也就实现了这个接口。
- 嵌入类型可以用来复用代码，也可以间接实现一些继承才能实现的能力。
- 总体而言，更像C语言。

#### 接口是用来定义行为的**类型** 

#### 接口值（接口的内部实现）
接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针，这个内部表叫做iTable，包含了所存储的值得类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。

#### 方法集
- 定义了一组关联到给定类型的值或指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。
- 规则  

values|method receivers
--|--
T|(t T)
*T|(t T) and (t *T)

method receivers|values
--|--
(t T)|T and T*
(t *T)| *T

### 嵌入类型
- 嵌入类型（type embedding）是将已有的类型直接声明在新的类型结构里。被嵌入的类型被称为新的外部类型的内部类型。
- 通过嵌入类型，与内部类型相关的标识符会提升到外部类型上，这些被提升的标识符就像直接声明在外部类型的标识符一样，也是外部类型的一部分。
- 外部类型可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段和方法（间接多态，复用代码）

### 代码实例
```
// user defines a user in the program.
type user struct {
	name  string
	email string
}

// notify implements a method that can be called via
// a value of type user.
func (u *user) notify() {
	fmt.Printf("Sending user email to %s<%s>\n",
		u.name,
		u.email)
}

// user 嵌入类型
type admin struct {
	user  // 嵌入类型，如果想要覆盖notify方法，直接重新定义就可以
	level string
}
```
```
// notify implements a method that can be called via
// a value of type Admin.
func (a *admin) notify() {
	fmt.Printf("Sending admin email to %s<%s>\n",
		a.name,
		a.email)
}
// main is the entry point for the application.
func main() {
	// Create an admin user.
	ad := admin{
		user: user{
			name:  "john smith",
			email: "john@yahoo.com",
		},
		level: "super",
	}

	// Send the admin user a notification.
	// The embedded inner type's implementation of the
	// interface is NOT "promoted" to the outer type.
	sendNotification(&ad)

	// We can access the inner type's method directly.
	ad.user.notify()

	// The inner type's method is NOT promoted.
	ad.notify()
}
```

### 公开和未公开的标识符
- 小写字母开头，未公开。
- 大写字母开头，公开。
- 短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。