### 数组
1. 在go里，数组是一个长度固定的数据类型，其占用的内存是连续分配的。  
2. 在Go里，数组是一个值，这意味着数据可以用在赋值操作里（是值的复制，int型复制的就是实际的数字，指针类型复制的就是地址）
3. 从内存和性能看，在函数之间传递数组是一个很大的开销，因为在函数之间传递变量时，总是以值的方式传递，如果这个变量是一个数组，意味着整个数组不管多长，都会完整复制，并传递给函数。

#### 声明和初始化
```
//方式一
var array [5]int
//方式二
array := [3]int{10, 20, 30}
//方式三
array := [...]int{10, 20, 30}
//方式四
array := [3]int{0:10, 2:30}

``` 

### 切片
- 切片是围绕动态数据概念构建的，可以按需自动增长和缩小。切片的动态增长通过内置函数append来实现。  
- 切片的底层内存是在连续块中分配的，所以切片可以获得索引、迭代以及垃圾回收优化的好处。  
- 切片的关键的三个属性：指向底层数组的指针，切片访问的元素的个数（长度）和切片允许增长到的元素的个数（容量）
- 切片只能访问到其长度内的元素，**与切片的容量相关联的元素只能用于增长切片，在使用这部分元素前，必须将其合并到切片的长度里**

#### 创建初始化
```
//方式一 空字符串切片，长度和容量都是5
slice := make([]string, 5)
//方式二 长度为3，容量为5
slice := make([]int, 3, 5)
//方式三：长度和容量都是3
slice := []int{10, 20, 30}
//方式四：使用空字符串初始化第100个元素
slice := []string{99:""}
```

#### nil切片和空切片
- 声明时不做任何初始化，就会创建一个nil切片: `var slice []int`
- 声明空切片：`slice := []int{}`

#### 切片的使用
##### 赋值
```
slice[1] = 5
// newSlice和slice共享同一段底层数组 newSlice的长度是3-1=2，容量比slice少1
newSlice := slice[1:3]

```
##### append
```
//使用原有的容量来分配一个新元素，并赋值为60
slice = append(slice, 60)
```
**如果切片的底层数组没有足够的可用容量，append函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。**当前的增长逻辑：切片容量小于1000时，成倍增长，超过1000，增长因子为1.25.

##### 迭代
**range创建了每个元素的副本，而不是之间返回对该元素的引用**  
```
for index, value := range slice {
...
}
```

##### 内置函数
- len：返回切片的长度
- cap：返回切片的容量

### 映射
- 在go里，映射的实现使用了散列。
- 可以使用类似处理数组和切片的范式来迭代映射中的元素，但需要注意的是，映射是无序的。
- 在函数间传递映射不会制造出映射的一个副本，传递的是引用
- 映射的键可以是任何类型（内置类型，结构类型），只要这个值可以使用==运算符做比较。切片、函数以及包含切片的结构类型由于具有引用语义，不能作为映射的键。

#### 创建和初始化
```
//键的类型是string，值得类型是int
dict := make(map[string]int)
//创建并初始化
dict := map[int]string{1:"Red", "2":"Blue"}
```
#### 使用样例
- 从映射取值并判断键是否存在  
```
value, exists := colors["blue"]
if exists {
   ...
}
```
- 使用range迭代映射
```
for key, value := range colors {
...
}
```
- 从映射中删除一项
```
delete(colors, "blue")
```