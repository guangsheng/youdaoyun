##### 函数参数默认值使用常犯错误
```
>>> def foo(bar=[]):
...    bar.append('baz')
...    return bar
...
>>> foo()
['baz']
>>> foo()
['baz', 'baz']
>>>
```
> 一个函数参数的默认值，仅仅在该函数定义的时候，被赋值一次  

正确定义

```
>>> def foo(bar=None):
...     if bar is None:
...         bar = []
...     bar.append('baz')
...     return bar
...
>>> foo()
['baz']
>>> foo()
['baz']
>>>
```

##### 错误使用类变量
```
>>> class A(object):
...     x = 1
...
>>> class B(A):
...     pass
...
>>> class C(A):
...     pass
...
>>> print A.x, B.x, C.x
1 1 1
>>> B.x = 2
>>> print A.x, B.x, C.x
1 2 1
>>> A.x = 3
>>> print A.x, B.x, C.x
3 2 3
>>>
```
> 在python中，类常量被当做字典来处理并遵循通常所说的**方法解析顺序（Method Resolution Order)**。因此在上面的代码中，因为属性X在C类中找不到，所以它会向上找他的基类中的。B.x没有问题是因为B.x=2这步将B.x引用到了2这个对象中，如果没有这部，B.x也是引用到A的x上的。

##### 异常处理时错误的使用参数
```
>>> try:
...     l = ["a", "b"]
...     int(l[2])
... except ValueError, IndexError:
...     pass
...
Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
IndexError: list index out of range
>>>
>>>
>>> try:
...     l = ["a", "b"]
...     int(l[2])
... except (ValueError, IndexError) as e:
...     pass
...
>>>
```
> 语法理解错误，语法```except exception, e```使用来讲异常和这个可选的参数绑定起来，以用来在后面查看的。

##### 误解Python作用域的规则
```
>>> lst =  [1, 3, 5]
>>> def foo1():
...     lst.append(7)
...
>>> lst
[1, 3, 5]
>>> foo1()
>>> lst
[1, 3, 5, 7]
>>> def foo2():
...     lst += [9]
...
>>> foo2()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in foo2
UnboundLocalError: local variable 'lst' referenced before assignment
>>>
```
> Python的作用域解析是基于叫做LEGB(Local, Enclosing, Global, Built-in)的规则来操作的。
> 在一个作用域里给一个变量**赋值**时，Python自动认为这个变量是这个作用域里的本地变量，并屏蔽作用域外的同名变量。

##### 后期绑定
```
>>> def create_mul():
...     return [lambda x : i * x for i in range(5)]
...
>>> for multiplier in create_mul():
...     print multiplier(2)
...
8
8
8
8
8
>>>

>>> def create_mul():
...     return [lambda x, i=i : i * x for i in range(5)]
...
>>> for multiplier in create_mul():
...     print multiplier(2)
...
0
2
4
6
8
>>>
```
> 在闭包中使用的变量的值，是在内层函数调用的时候查找的，在上面的代码中，当任一返回函数被调用时，i的值是在**它被调用时的周围作用域**中查找的（到那时，），