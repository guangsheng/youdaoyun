### 基本概念
+ 并发和并行：并发（concurrency）不是并行（parallelism）。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情。而并发是指同时管理很多事情。这些事情可能只做到一半就被暂停去做别的事情了。就比如我们工作时，同时做很多事情，是并发而不是并行。
+ 线程可以被中断（抢占，进程也可以）和临时挂起（让核或等待同步）。
+ 竞争和同步

### python线程
+ **python解释器中可以运行多个线程，但任意指定时刻只有一个线程会被解释器执行**（Why：Python解释器是运行在一个CPU上的？）。
+ 对Python解释器（也叫Python虚拟机）的访问是由全局解释器锁（GIL）控制的。这个锁保证了同时只有一个线程被调用。
    1. 设置GIL
    2. 切换进一个线程去运行
    3. 执行下面的操作之一
        - 执行指定数量的字节码指令
        - 线程主动让出控制权
    4. 把线程设置会睡眠状态，并切换出线程
    5. 解锁GIL
    6. 重复上述步骤
+ Python的线程是并发，而不是并行，这个特性决定了，它更善于处理IO密集型（也就是各个线程运行过程中会有如读写，网络访问等阻塞性操作）场景，对于计算密集型场景性能提升并不大。

### threading模块
#### 相关对象
对象（类）|描述
---|---
Thread|表示一个执行线程的对象
Lock|锁原语对象
RLock|可重入锁对象，使单一线程可以再次获取已持有的锁（递归锁）
Condition|条件变量对象，使得一个线程等待另一个线程满足特定的条件，比如改变状态或某个数据值
Event|条件变量的通用版本，任意数量的线程等待某个条件的发生，在该事件发生后所有线程会被激活。
Semaphore|信号量，就是一个计数器。如果没有可用资源时会被阻塞
BoundedSemaphore|有边界的信号量，即它不允许超过初始值
Timer|与Thread类似，不过它在运行前等待要等待一段时间
Barrier|栅栏，必须达到指定数量的线程后才可以继续

#### 守护线程
+ 如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成。
+ 一个新的子线程会继承父线程的守护标记
+ 整个python程序在所有非守护线程退出后才会退出。
+ 要将一个线程设置为守护线程，需要在启动线程前执行如下赋值语句:```thread.daemon = True```

#### Thread类
##### Thread对象的属性和方法
属性|描述
---|---
数据属性|
name|线程名
ident|线程的标识符
daemon|布尔型，表示这个线程是否是守护线程
方法|
\_\_init\_\_(self, group=None, target=None, name=None,args=(), kwargs=None, verbose=None)|实例化一个线程对象，需要有一个可调用的target以及参数args或kwargs。还可以传递name或group参数。
start()|开始执行该线程
run()|定义线程功能的方法（通常在子类中被应用开发者重写）
join(timeout=None)|直至启动的线程终止之前一直挂起，除非给出了timeout（秒）。
is_alive()|布尔型，表示这个线程是否还存活。
##### 创建一个线程的三种方法
+ 创建Thread的实例，传给它一个函数
+ 创建Thread的实例，传给它一个可以调用的类实例
+ 派生Thread的子类，并创建子类的实例

#### 锁和信号量
##### 锁
```python
from threading import BoundedSemaphore, Lock, Thread
lock = Lock()

# 示例1
lock.acquire()
do_something()
lock.release()

# 示例2
with lock:
    do_something()
```
##### 信号量
- 是一个计数器，当资源消耗时递减，资源释放时递增
- 消耗资源使计数器递减的操作习惯上称为P，也称为wait, try, acquire, pend等
- 资源释放使计数器值增加的操作习惯上称为V，也称为signal, increment, release, post等。
- python中，使用和锁的函数一样的名字：acquire和release

#### Queue模块
属性|描述
---|---
**Queue/queue模块的类**|
Queue(maxsize=0)|创建一个先入先出队列，如果给定最大值，则在队列没有空间时阻塞，否则为无限队列。
LifoQueue(maxsize=0)|后入先出队列
PriorityQueue(maxsize=0)|优先级队列
**Queue/queue异常**|
Empty|当对空队列调用get*方法时抛出
Full|当对已满的队列调用put*方法时抛出
**Queue/queue对象方法**|
qsize()|返回队列大小（非线程安全，返回时队列大小可能被其他线程修改，所以该值为近似值）
empty()|判断队列是否为空
full()|判断队列是否已满
put(item, block=True, timeout=None)|将item放入队列，如果block为True且timeout为None，则在有可用空间之前阻塞；如果Timeout为正值，则最多阻塞timout秒；如果block为False，则抛出Empty异常
put_nowait(item)|和put(item, False)想同
get(block=True, timeout=None)|从队列取得元素
get_nowait()|和get(False)相同
task_done()|用于表示队列中的某个元素已经执行完成。
join()|在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞

#### threading模块的其他函数
函数|描述
---|---
active_count()|当前活动的Thread对象个数
current_thread()|返回当前的Thread对象
enumerate()|返回当前活动的Thread对象列表
settrace(func)|为所有线程设置一个trace函数，在run之前调用
setprofile()func|为所有线程设置一个profile函数，在run之前调用
stack_size(size=0)|返回新创建线程的栈大小，或为后续创建的线程设定栈的大小为size

### 代码实例
```python
# -*- coding:utf-8 -*-

from random import randint
from time import sleep, ctime
from Queue import Queue
from atexit import register
import threading


class MyThread(threading.Thread):
    def __init__(self, func, args, name=''):
        threading.Thread.__init__(self)
        self.name = name
        self.func = func
        self.args = args
        self.res = ''

    def get_result(self):
        return self.res

    def run(self):
        print 'starting ', self.name, ' at:', \
            ctime()
        self.res = self.func(*self.args)
        print self.name, ' finished at:', ctime()


def write_q(queue):
    queue.put('xxx', 1)
    print 'producing object for Q... size now ', \
        queue.qsize()


def read_q(queue):
    queue.get(1)
    print 'consumed object from Q... size now ', \
        queue.qsize()


def writer(queue, loops):
    for i in range(loops):
        write_q(queue)
        sleep(randint(1, 3))


def reader(queue, loops):
    for i in range(loops):
        read_q(queue)
        sleep(randint(2, 5))

funcs = [writer, reader]
nfuncs = range(len(funcs))


@register
def _atexit():
    print 'all Done at:', ctime()


def main():
    nloops = randint(4, 6)
    q = Queue(32)
    threads = []

    for i in nfuncs:
        t = MyThread(funcs[i], (q, nloops), funcs[i].__name__)
        threads.append(t)

    for i in nfuncs:
        threads[i].start()


if __name__ == '__main__':
    main()

```