- ```a, b = b, a```
- 列表推导 list comprehension
    ```
    a = [1, 2, 3, 4, 5, 6, 7, 8 , 9 ,10]
    squares = [x**2 for x in a]
    
    even_squares = [x**2 for x in a if x % 2 == 0]
    
    chile_ranks = {'ghost': 1, 'habanero':2}
    rank_dict = {rank, name for name, rank in chile_ranks.items()}
    ```
- 序列切割 ```array[start, end, stride]```
    - list, str, bytes 都可以进行切割
    - 对原列表进行切割后，会产生另外一份全新的列表
    - ```a[:4]```  从左取从0到4
    - ```a[-4:]``` 从右取从0到4
    - 如果对赋值操作左侧的列表使用切片，而又没有指定起止索引，那么系统会把右侧的新值复制一份，并用这份拷贝来替换左侧列表的全部内容，而不会分配新的列表。如```a[:] = [101, 102]```,a列表不论之前是什么，赋值后就变成了[101, 102]
- ```try/except/else/finally```
    - try/except/finally 可以清晰的描述出哪些异常会有自己的代码处理，哪些异常会传播到上一级
- 生成器表达式 generator expression
    - 把实现列表推导所用的那种写法放在一堆圆括号中，就构成了生成器表达式
    - 生成器表达式求值的时候，他会立刻返回一个迭代器，而不会深入处理，可以避免内存用量的问题。
    - 把某个生成器表达式所返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者组合起来。
    ```
    >>> it = (len(x) for x in open('matplotlibtest.py'))
    >>> print it
    <generator object <genexpr> at 0x10bea6aa0>
    >>> print next(it)
    23
    >>> print next(it)
    19
    >>> roots = ((x, x**0.5) for x in it)
    >>> print(next(roots))
    (32, 5.656854249492381)
    >>>
    ```
- enumerate: 可以把各种迭代器包装成生成器，以便稍后产生输出值。该生成器每次产生一对输出值，其中，前者表示循环下标，后者表示从迭代器中获取到的下一个序列元素。
```
>>> flavor_list = ['vanilla', 'chocolate', 'pecan']
>>> for i, flavor in enumerate(flavor_list, 1):
...     print i, flavor
...
1 vanilla
2 chocolate
3 pecan
>>>
```

- 一些pythonic例子
    - 如果 or 操作符左侧的子表达式估值为False，那么整个表达式的值就将是or操作符右侧那个子表达式的值。如```red = my_valuse.get('ret') or 0```
    - 


#### python深入学习
- 编写Python程序时，一定要把编码和解码操作放在界面的最外围来做（分层）。程序的核心部位应该使用Unicode字符类型（也就是Python3中的str，Python2中的unicode）
- python中有种特殊语法，可以在for即while循环的内部语句块后紧跟一个else块，只有当整个循环主体没有遇到break语句时，循环后面的else块才会被执行。


#### python3与python2
- 在python3中，不能以> 或 + 等操作符来混同操作byte和str
- 
