JSON库模块允许将Python内置类型转换为基于文本的JSON数据交换各式  
使用json.dumps()可以创建一个Python类型的字符串版本，使用json.loads()可以从一个JSON字符串创建一个Python类型  
```json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)```

skipkeys：默认值是False，如果dict的keys内的数据不是python的基本类型
(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key  
ensure_ascii：默认值True，如果dict内含有non-ASCII的字符，则会类似\uXXXX的显示数据，设置成False后，就能正常显示  
check_circular：默认值True，如果设置为False，会跳过跳过容器类型的循环引用检查并报错OverflowError  
indent：应该是一个非负的整型，如果是0，或者为空，则一行显示数据，否则会换行且按照indent的数量显示前面的空白，这样打印出来的json数据也叫pretty-printed json  
separators：分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(',',':')；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。
sort_keys：将数据根据keys的值进行排序。    

```json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)```

示例：
```
import json

if __name__ == '__main__':
    # 将python对象test转换json对象
    test = [{"username":"测试","age":16},(2,3),1]
    print(type(test))
    python_to_json = json.dumps(test,ensure_ascii=False)
    print(python_to_json)
    print(type(python_to_json))

    python_to_json_tree = json.dumps(test,ensure_ascii=False,indent=1)
    print(python_to_json_tree)
    print(type(python_to_json_tree))

    # 将json对象转换成python对象
    json_to_python = json.loads(python_to_json)
    print(json_to_python)
    print(type(json_to_python))
```
输出结果：
```
<class 'list'>
[{"username": "测试", "age": 16}, [2, 3], 1]
<class 'str'>
[
 {
  "username": "测试",
  "age": 16
 },
 [
  2,
  3
 ],
 1
]
<class 'str'>
[{'username': '测试', 'age': 16}, [2, 3], 1]
<class 'list'>
```