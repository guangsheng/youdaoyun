#### 理解
- Python中的函数、类都是一种对象。这意味着函数与类都可以作为参数提供、以类实例的成员形式存在，且可以完成其他对象所能完成的工作。
- 负责生成其他类的类就是元类。
- **type时Python中的内置类，该类时其他类对象的默认类，或者说是默认元类**。默认情况下，使用class关键字创建的类都使用type作为其元类。
- ```louisoix = Cat(name = 'Louisoix)```  louisoix是一个对象，也是Cat的实例。Cat类也是一个对象，同时也是type的实例。type是继承链的顶端。
- Python的继承模型要求任何类都只能有一个元类。

#### 何用？
- 通常通过重载__new__方法来实现一些功能，比如要求传入的参数中必须有a或有b
- 在类声明与类结构之间创建描述，尤其是创建供其他开发人员使用的API时（如Django）。  
    Django:1. 将类声明前置与前台，然后在__new__方法中将该类的声明转换为实际类的结构。2. 一个模型代表一个表，模型中的属性代表表中的列。

#### 语法
##### python3
```
#1
class C(metaclass=Meta):
#2
class C(object, metaclass=Meta):
#3
import six
class C(six.with_metaclass(Meta)):
#4
import six

@six.add_metaclass(Meta)
class C(object):
```
##### python2
```
class C(object):
    __metaclass__ = Meta
```

#### 实例
```
class Logged(type):
    """A metaclass that causes classes that it creates to log
    their function calls
    """
    def __new__(cls, name, bases, attrs):
        for key, value in attrs.items():
            if callable(value):
                attrs[key] = cls.log_call(value)
        return super(Logged, cls).__new__(cls, name, bases, attrs)

    @staticmethod
    def log_call(fxn):
        """Given a function, warp it with some logging code and
        return the warpped function 
        """
        def inner(*args, **kwargs):
            print('The function %s was called with arguments %r and '
                  'keyword arguments %r.' % (fxn.__name__, args, kwargs))
            try:
                response = fxn(*args, **kwargs)
                print('The function call to %s was successful.' %
                      fxn.__name__)
                return response
            except Exception as exc:
                print('The function call to %s raised an exception: %r' %
                      (fxn.__name__, exc))
                raise
        return inner
```