### 介绍
装饰器就是一个可以**接受调用**也可以**返回调用**的调用（调用可以理解为函数、方法）。  
装饰器无非就是一个函数，该函数接受被装饰的函数作为其位置参数

**一个可调用函数接受一个可调用函数返回一个可调用函数**  
**类本身就是一个函数**
### 作用
避免重复的工具，为代码的未来维护提供钩子。
### 语法
Python2.5为装饰器引入了特殊的语法。装饰器的应用是通过在装饰器的名称前放置一个@字符，并在被装饰函数声明之上添加一行的方式来实现的。  
**特别注意**：对于某个可调用函数，可以使用多个装饰器。如果通过@语法使用装饰器，就需要按照自底向上的顺序来应用他们。比如
```
@aslo_decoreated_by
@decoreated_by
def add(x,y):
    ....
==>
aslo_decoreated_by(decoreated_by(add))
```

### 注意和陷阱
- @json_output 和 @json_output() 不重复也不等价
- 装饰器也可以被用于装饰类（应为类本身也是可调用函数）

### 装饰器参数
- 传递给装饰器的参数只被处理一次，即在函数声明并被装饰时处理。与之相反，传递给函数的参数在函数被调用时处理。
- 接受参数的装饰器并不是实际的装饰器，而是一个返回装饰器的函数，该函数接受一个参数（被装饰的方法），让后装饰函数并返回一个可调用函数。
- Why：函数在装饰器的应用语法@之前调用，这样@后实际跟的是函数的返回值，也就是"接受参数的装饰器并不是实际的装饰器，而是一个返回装饰器的函数"

### 实际应用例子
#### 函数注册表
```python
#coding=utf-8

class Registry(object):
    def __init__(self):
        self._functions = []

    def register(self, decorated):
        self._functions.append(decorated)
        return decorated
    def run_all(self, *args, **kwargs):
        return_values = []
        for func in self._functions:
            return_values.append(func(*args, **kwargs))
        return return_values

a = Registry()

@a.register
def foo(x=3):
    return x

@a.register
def bar(x=5):
    return x

print a.run_all()
```

result
```
[3, 5]
```
#### 封装代码
如类型检查、输出格式化、日志管理等
##### 几个Python原生的装饰器
```
# functools中的 @functools.wraps 将一个函数的重要内部元素复制到另一个函数，比如方式装饰器修改掉函数help信息
```

##### 类型检查
```python
#检查参数类型是否都是整数
def requires_ints(decorated):
    def inner(*args, **kwargs):
        kwarg_values = [i for i in kwargs.values()]
        for arg in list(args) + kwarg_values:
            if not isinstance(arg, int):
                raise TypeError('%s only accept integers as argument.' %
                                decorated.__name__)
        return decorated(*args, **kwarg_values)
    return inner
```


##### 输出格式化
```python
#coding=utf-8

import functools
import json

class JSONOutputError(Exception):
    def __init__(self, message):
        self._message = message

    def __str__(self):
        return self._message

def json_output(decorated):
    @functools.wraps(decorated)
    def inner(*args, **kwargs):
        try:
            result = decorated(*args, **kwargs)
        except JSONOutputError as ex:
            result = {
                'status':'error',
                'message':str(ex),
            }
        return json.dumps(result)
    return inner

def error():
    raise JSONOutputError("This function is erratic.")

error()
```
result
```
Traceback (most recent call last):
  File "/Users/shiguangsheng/Desktop/MyZone/work/pycharm_project/com/fisher/test/json_decorated.py", line 29, in <module>
    error()
  File "/Users/shiguangsheng/Desktop/MyZone/work/pycharm_project/com/fisher/test/json_decorated.py", line 27, in error
    raise JSONOutputError("This function is erratic.")
__main__.JSONOutputError: This function is erratic.
```

##### 函数执行时间记录和日志
```python
#coding=utf-8
import functools
import time

def logged(method):
    @functools.wraps(method)
    def inner(*args, **kwargs):
        start = time.time()
        return_value = method(*args, **kwargs)
        end = time.time()
        delta = end - start

        print('Called method %s at %.02f; execution time %.02f '
                    'seconds; result %r.' %
                    (method.__name__, start, delta, return_value))
        return return_value
    return inner

@logged
def sleep_and_return(return_value):
    time.sleep(2)
    return return_value

sleep_and_return(42)
```
result
```
Called method sleep_and_return at 1495373710.44; execution time 2.00 seconds; result 42.
```

### 装饰类
```python
import functools
import time

def sortable_by_creation_time(cls):
    original_init = cls.__init__
    @functools.wraps(original_init)
    def new_init(self, *args, **kwargs):
        original_init(self, *args, **kwargs)
        self._created = time.time()
    cls.__init__ = new_init

    cls.__lt__ = lambda self, other: self._created < other._created
    cls.__gt__ = lambda self, other: self._created > other._created

    return cls

@sortable_by_creation_time
class Sortable(object):
    def __init__(self, identifier):
        self.identifier = identifier
    def __repr__(self):
        return self.identifier


import functools
import time


def sortable_by_creation_time(cls):
    original_init = cls.__init__

    @functools.wraps(original_init)
    def new_init(self, *args, **kwargs):
        original_init(self, *args, **kwargs)
        self._created = time.time()

    cls.__init__ = new_init

    cls.__lt__ = lambda self, other: self._created < other._created
    cls.__gt__ = lambda self, other: self._created > other._created

    return cls
first = Sortable('first')
second = Sortable('second')
third = Sortable('third')

sortables = [second, first, third]
print sorted(sortables)
```
result
```
[first, second, third]
```

### 类型转换(接受一个函数，返回一个类)
python生态系统的流行任务执行器中使用的装饰器是celery. celery宝提供的@celery.task装饰器期望装饰一个函数，而该函数实际上回返回celery内部的Task类，而被装饰的函数在子类的run方法中被调用。下面是一个模拟实现。
```python
#coding=utf-8

class Task(object):
    #如果不定义这个方法，使用 func() 这种方式调用函数时，并不会真正调用这个函数，而是返回一个类说明
    def __call__(self, *args, **kwargs):
        return self.run(*args, **kwargs)

    def run(self, *args, **kwargs):
        raise NotImplementedError('Subclass must implement run.')

    def identify(self):
        return 'I am a task.'

def task(decorated):
    class TaskSubclass(Task):
        def run(self, *args, **kwargs):
            return decorated(*args, **kwargs)
    return TaskSubclass()

@task
def foo():
    return 4

print foo()
print foo
print foo.identify()
```
result
```
4
<__main__.TaskSubclass object at 0x10ec2ca10>
I am a task.
```