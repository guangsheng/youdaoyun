#### 作用
通过自己的代码提前去做一系列工作或存储一堆数据是没有好处的，生成器处理值序列时允许序列中的每一个值只在需要时计算，而不是像传统列表那样一定要提前计算好。在恰当的地方使用可以减少计算量和降低内存消耗。

#### 理解生成器
生成器是一个函数，生成器函数执行直到被通知输出一个值，然后会继续执行直到再次被通知输出值。直到函数完成或生成器之上的迭代完成。

#### 语法
使用yield替换return  

像return语句一样，yield会返回一个值给调用者，但与return不同的是，yield不会终止函数的执行，而是暂时停顿直到调用代码重新恢复生成器，在停顿的地方再次开始执行。

```
def fibonacci(maxloop):
    numbers = []
    loop_i = 0
    while True:
        loop_i = loop_i + 1
        if len(numbers) < 2:
            numbers.append(1)
        else:
            numbers.append(sum(numbers))
            #memmory
            numbers.pop(0)
        if (loop_i > maxloop):
            raise StopIteration
        yield numbers[-1]

for i in fibonacci(4):
    print i
```
result
```
1
1
2
3
```

#### 高级用法
- StopIteration  
    用于生成器退出。for不会报错，next会抛异常
- next  
    python提供了内置的next函数，能够让生成器（事实上，在python2中任何带有__next__方法的对象都称为next）请求它的一个值。  
    next与for的区别，for碰到StopIteration不会报错，next会报错
- send  
    如果使用send方法而不是next重启生成器，那么提供给send方法的值会被赋给**yield表达式的结果**。在生成器中可以接受这个值，然后根据实际需要进行处理。

示例
```
print "test text"
gen = fibonacci(4)
next(gen)
next(gen)
next(gen)
print next(gen)
print next(gen)
```
result
```
test text
Traceback (most recent call last):
3
  File "D:/MyZone/work/code/python/project/python_scrapy/com/fisher/Test.py", line 21, in <module>
    print next(gen)
  File "D:/MyZone/work/code/python/project/python_scrapy/com/fisher/Test.py", line 13, in fibonacci
    raise StopIteration
StopIteration
```

#### 系统生成器
- range  
    有一个可选的第三方参数step
- dict.items及其家族  
    kyes, values, items
- zip
- map
- 文件对象
    readline和next方法的区别：readline对StopIteration异常做了特殊处理，会捕获这个异常并返回空串。

#### 迭代对象和迭代器
- 生成器是一种迭代器
- 迭代器是包含__next__方法的任何对象
- 迭代对象是任何定义了__iter__方法的对象。__iter__方法负责返回一个迭代器。

**说明**
- 生成器可以是迭代器，但不一定是迭代对象。
- 并非所有的迭代对象都是迭代器。


#### 迭代类
```python
class Fibonacci(object):
    def __init__(self):
        self.numbers = []

    def __iter__(self):
        return self

    def __next__(self):
        if len(self.numbers) < 2:
            self.numbers.append(1)
        else:
            self.numbers.append(sum(self.numbers))
            self.numbers.pop(0)
        return self.numbers[-1]

    def send(self, values):
        pass

    #for python2 compatibility
    next = __next__

f = Fibonacci()
i1 = iter(f)
print next(i1)
print next(i1)
print next(i1)
i2 = iter(f)
print next(i2)
```
result
```
1
1
2
3
```