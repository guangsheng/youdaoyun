#### 说明
任何抽象基类，无论他们的目的是什么，必须使用abc模块的ABCMeta元类。  

#### 作用一： 提供有点形式化的方法来测试一个对象是否符合特定规范（isinstace,issubclass)
ABCMeta的实例通过使用register方法提供了对声明的实现
 
#### 通过实际例子理解
```python
>>> import abc
>>> class AbstractDict(object):
...     __metaclass__ = abc.ABCMeta
...     def foo(self):
...         return None
... 
>>> AbstractDict.register(dict)  ##声明AbstractDict是dict的抽象基类
>>> print AbstractDict
<class '__main__.AbstractDict'>
>>> issubclass(dict, AbstractDict)  ##dick是AbstractDict的子类
True
>>> isinstance({}, AbstractDict)  ## 字典时AbstractDict的一个实例
True
>>> 
```

#### __subclasshook__
**在鸭子类型范例中，最根本的的问题是，一个对象是否有某个方法或属性，而不是对象是否是这个或那个类的子类**

#### 通过实际例子理解
下面这个抽象基类声明，任何带有quack方法的类都被认为是他的子类，而任何其他类都不是他的子类。当__subclasshook__方法被定义时，它优先于register方法。
```python
import abc

class AbstractDuck(object):
    __metaclass__ = abc.ABCMeta
    
    @classmethod
    def __subclasshook__(cls, other):
        quack = getattr(other, 'quack', None)
        return callable(quack)
```

#### 作用二：类似于java等面向对象语言中接口的概念。用于声明协议，定义子类必须提供的内容
#### 实例
##### 实现方法一：用NotImplementedError
```python
def _run(self):
    raise NotImplementedError('Subclasses must define a _run method')
```
##### 实现方法二：使用元类
```python
def __new__(cls, name, bases, attrs):
    ...
    if not hasattr(new_class, '_run') or not callable(new_class._run):
        raise TypeError('Subclasses must define a _run method')
```
##### 实现方法三：使用抽象基类
```python
import abc
from datetime import datetime

class Task(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self):
        self.runs = []

    def run(self):
        start = datetime.now()
        result = self._run()
        end = datetime.now()
        self.runs.append({
            'start':start,
            'end':end,
            'result':result,
        })
        pass

    @abc.abstractmethod
    def _run(self):
        pass
```

#### 内置抽象类
- Callable(__call__)
- Container(__contains__)
- Hashable(__hash__)
- Iterable(__iter__)
- Sized(__len__)