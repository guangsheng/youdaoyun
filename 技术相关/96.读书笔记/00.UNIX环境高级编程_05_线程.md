#### 线程标识 pthread_t

```
int pthread_equal(pthread_t t1, pthread_t t2);
pthread_t pthread_self(void);
```
进程的所有数据对该进程的所有线程都是共享的，包括可执行的程序文本，程序的全局内存和堆内存、栈以及文件描述符。

#### 线程创建

```
#include <pthread.h>

int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
```

#### 线程终止
- 从启动例程中返回
- 被同一进程的其他线程取消
- 线程调用pthread_exit
- pthread_join  调用线程将一直阻塞，直到指定的线程终止，这个函数的返回值是线程的终止状态（pthread_exit传递的那个值）
- 如果对线程的终止状态不感兴趣，可以调用pthread_detach让操作系统在线程退出时收回它所占用的资源（也就是分离状态）

```
void pthread_exit(void *value_ptr);
int pthread_join(pthread_t thread, void **value_ptr);
int pthread_cancel(pthread_t thread);

void pthread_cleanup_push(void (*cleanup_routine)(void *), void *arg);
void pthread_cleanup_pop(int execute);
```

#### 线程同步
- 互斥量：加锁，不加锁

```
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

- 读写锁：读模式加锁，写模式加锁，不加锁

```
#include <pthread.h>

int pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr);
int pthread_rwlock_destroy(pthread_rwlock_t *lock);

int pthread_rwlock_rdlock(pthread_rwlock_t *lock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *lock);
int pthread_rwlock_wrlock(pthread_rwlock_t *lock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *lock);
int pthread_rwlock_unlock(pthread_rwlock_t *lock);
```

- 条件变量:
	- 条件变量给多个线程提供了一个会和的场所（各个线程以无竞争的形态等待某个条件达成）
	- 条件本身有互斥量保护。线程在改变条件状态前必须首先锁住互斥量。

```
#include <pthread.h>

int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cond);

int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
```

#### 扩展
- 线程属性
	- 可分离状态
	- 可取消状态： 当可取消状态为DISABLE时，pthread_cancel无法取消线程，而是将线程变成了未决状态
	- 可取消类型
	- 并发度（用户级线程可以映射的内核进程或线程的数目）
- 互斥量属性
	- 共享属性： 如果互斥量的进程共享属性设置为PTHREAD_PROCESS_SHARED，则可以用这个互斥量控制共享内存的同步访问。
	- 类型属性： 没有解锁时再次枷锁？不占用时解锁？在已解锁时解锁？
- 读写锁属性： 进程共享属性

- 每个线程都有自己的信号屏蔽字，但是信号的处理是所有线程共享的。如果信号与硬件故障或计时器超时有关，该信号就被发送到引起该事件的线程中去，而其他信号则被发送到任意一个线程。

- 当线程调用fork时，子进程从父进程继承了所有互斥量、读写锁等。子进程内部只有一个线程，它是由父进程中调用fork的线程的副本构成的。子进程并不包含占有锁的所有线程的副本，所以子进程没有办法知道他占有了哪些锁，并且需要释放哪些锁。

