#### 进程标识符 pid
- 0号进程： 调度进程，交换进程
- 1号进程： init进程

#### 创建子进程： fork/vfork
- fork函数调用一次，返回两次。子进程的返回值是0
- 子进程和父进程会继续执行fork调用后的指令
- 子进程是父进程的副本（数据空间、堆、栈，使用写时复制技术），父子进程共享正文段。
- 文件共享：父进程所有的文件描述符会复制给子进程，父子进程对同一文件使用了一个偏移量。
- 子进程继承父进程的：文件、用户组ID、会话ID、控制终端、当前工作目录、根目录、文件模式创建屏蔽字、信号屏蔽和安排、存储映射、资源限制等
- 父子进程不同的：fork返回值、PID、父进程文件锁子进程不继承、子进程的未处理信号集设置为空集、子进程的未处理闹钟（alarm）被清除、子进程的tms_utime,tms_stime均被设置为0
- vfork用于创建一个新进程，而该新进程的目的是exec一个新程序。它并不将父进程的地址空间完全复制到子进程中，相反，在子进程调用exec或exit之前，**它在父进程的空间中运行**。

#### 进程退出
- 正常退出： main里return，exit，最后一个线程pthread_exit()
- 异常退出： abort，收到某些信号，最后一个线程对取消信号做出响应
- 对于父进程已经终止的所有进程，它们的父进程都改变为init进程
- wait/waitpid/waittid
- 在Unix中。_exit并不清洗标准IO流，但是exit会清洗标准IO流

#### 使用exec执行新程序
- exec用一个全新的程序替换了当前进程的正文、数据、堆和栈段。

```c
     #include <unistd.h>

     extern char **environ;

     int
     execl(const char *path, const char *arg0, ... /*, (char *)0 */);

     int
     execle(const char *path, const char *arg0, ... /*, (char *)0, char *const envp[] */);

     int
     execlp(const char *file, const char *arg0, ... /*, (char *)0 */);

     int
     execv(const char *path, char *const argv[]);

     int
     execvp(const char *file, char *const argv[]);

     int
     execvP(const char *file, const char *search_path, char *const argv[]);
```

#### 用户和组
- 程序的超级用户权限在执行了fork和exec之后仍旧会保留下来。

