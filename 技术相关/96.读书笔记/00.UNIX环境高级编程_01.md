#### 一些需要记忆的点
+ pid = fork()  pid = 0 是子进程，为什么？因为在子进程中可以通过getpid和getppid获取本进程id以及父进程id，而父进程没有一个函数可以获取子进程ID（一个子进程只会有一个父进程，而一个父进程可以有多个子进程）
+ 同一进程的多个线程之间共享： 同一地址空间、文件描述符、栈以及与进程相关的属性
+ errno是线程安全的，另外一定是在函数调用出错的情况下才使用errno

```C
# ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __THROW __attribute__ ((__const__));
 #  if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value.  */
#   define errno (*__errno_location ())
#  endif
# endif /* !__ASSEMBLER__ */
```
+ 系统调用和库函数：我们可以重写库函数，但没有办法重写系统调用
+ 一些系统数据文件
	- /etc/passwd
	- /etc/group
	- shadow文件（记录加密后口令）
	- 附加组文件（一个用户属于多个组，类似于角色的作用）
	- /etc/protocols
	- /etc/services
	- /etc/hosts 

#### UNIX域套接字
UNIX域套接字提供流和数据报两种接口。UNIX域数据报服务是可靠的，既不会丢失消息也不会传递出错。UNIX域套接字是套接字和管道之间的混合物。

```c
#include "apue.h"
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>
#include <time.h>

#define    QLEN    10

/*
* Create a server endpoint of a connection.
* Return fd if all ok, <0 on error. 
*/
int
serv_listen(const char *name)
{
    int            fd, len, err, rval;
    struct sockaddr_un    un;
    
    /* create a UNIX domain stream socket */
    if((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
        return(-1);
    unlink(name);    /* in case it already exists */

    /* fill in socket address structure */
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    strcpy(un.sun_path, name);
    len = offsetof(struct sockaddr_un, sun_path) + strlen(name);

    /* bind the name to the descriptor */
    if(bind(fd, (struct sockaddr *)&un, len) < 0)
    {
        rval = -2;
        goto errout;
    }
    if(listen(fd, QLEN) < 0)    /* tell kernel we're a server */
    {
        rval = -3;
        goto errout;
    }
    return(fd);

errout:
    err = errno;
    close(fd);
    errno = err;
    return(rval);
}

#define STALE    30    /* client's name can't be older than this (sec) */

/*
* Wait for a client connection  to arrive, and accept it.
* We also obtain the client's usr ID from the pathname
* that it must bind before calling us.
* Returns new fd if all ok, <0 on error
*/
int serv_accept(int listenfd, uid_t *uidptr)
{
    int                   clifd, len, err, rval;
    time_t                staletime;
    struct sockaddr_un    un;
    struct stat           statbuf;
    
    len = sizeof(un);
    if((clifd = accept(listenfd, (struct sockaddr *)&un, &len)) < 0)
        return(-1);    /* often errno=EINTR, if signal caught */

    /* obtain the client's uid from its calling address */
    len -= offsetof(struct sockaddr_un, sun_path);    /* len of pathname */
    un.sun_path[len] = 0;    /* null terminate */

    if(stat(un.sun_path, &statbuf) < 0)
    {
        rval = -2;
        goto errout;
    }
#ifdef    S_ISSOCK    /* not defined fro SVR4 */
    if(S_ISSOCK(statbuf.st_mode) == 0)
    {
        rval = -3;    /* not a socket */
        goto errout;
    }
#endif
    if((statbuf.st_mode & (S_IRWXG | S_IRWXO)) ||
           (statbuf.st_mode & S_IRWXU) != S_IRWXU)
    {
        rval = -4;    /* is not rwx------ */
        goto errout;
    }
    
    staletime = time(NULL) - STALE;
    if(statbuf.st_atime < staletime ||
       statbuf.st_ctime < staletime ||
       statbuf.st_mtime < staletime)
    {
        rval = -5;    /* i-node is too old */    
        goto errout;
    }
    
    if(uidptr != NULL)
        *uidptr = statbuf.st_uid;    /* return uid of caller */
    unlink(un.sun_path);    /* we're done with pathname now */
    return(clifd);

errout:
    err = errno;
    close(clifd);
    errno = err;
    return(rval);    
}

#define CLI_PATH    "/var/tmp/"    /* +5 fro pid = 14 chars */
#define CLI_PERM    S_IRWXU        /* rwx for user only */

/*
* Create a client endpoint and connect to a server.
* Returns fd if all ok, <0 on error. 
*/
int 
cli_conn(const char *name)
{
    int            fd, len, err, rval;
    struct sockaddr_un    un;
    
    /* create a UNIX domain stream socket */
    if((fd = socket(AF_UNIX, SOCK_STREM, 0)) < 0)
        return(-1);

    /* fill socket address structure with our address */
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    sprintf(un.sun_path, "%s%05d", CLI_PATH, getpid());
    len = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);

    unlink(un.sun_path);    /* in case it already exits */
    if(bind(fd, (struct sockaddr *)&un, len) < 0)
    {
        rval = -2;
        goto errout;
    }
    if(chmod(un.sun_path, CLI_PERM) < 0)
    {
        rval = -3;
        goto errout;
    }

    /* fill socket address structure with server's address */
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    strcpy(un.sun_path, name);
    len = offsetof(struct sockaddr_un, sun_path) + strlen(name);
    
    if(connect(fd, (struct sockaddr *)&un, len) < 0)
    {
        rval = -4;
        goto errout;
    }
    return(fd);

errout:
    err = errno;
    close(fd);
    errno = err;
    return(rval);
    
}


```