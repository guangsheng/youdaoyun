### 1 总体原则
+ 更小的通常更好
+ 更简单的通常更好
+ 尽量避免NULL

+ 不要有太多的列或太多的关联（MySQL不允许有超过61个关联的查询）
+ 小心使用ENUM和SET
+ 尽量使用相同数据类型存储相似或相关的值，尤其是要在关联条件中使用的列

### 2 注意事项
+ 注意可变长字符串，其在临时表和排序是可能导致悲观的按最大长度分配内存。

### 3 数据类型
#### 3.1 整数类型
+ TINYINT    8位
+ SMALLINT  16位
+ MEDIUMINT 24位
+ INT       32位
+ BIGINT    64位

+ 整数类型有可选的UNSIGNED属性
+ 对于存储和计算来说，INT(1)和INT(20)是相同的，后面的指定宽度并不会限制值得合法范围，只是规定了一些工具的显示字符的个数。

#### 3.2 实数类型
+ FLOAT, DOUBLE, DECIMAL
+ FLOAT, DOUBLE使用标准浮点运算进行**近似**计算，DECIMAL用于精确计算
+ FLOAD使用4个字节存储，DOUBLE使用8个字节存储
+ DECIMAL(18,9)小数点两边将各存储9个数字，一共使用9个字节，小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占用1个字节。
+ 尽量只在对小数进行精确计算的时候才使用DECIMAL
+ **小技巧**：在数据量比较大的时候，可以使用BIGINT代替DECIMAL

#### 3.3 字符串类型
+ VARCHAR ：用于存储可变长字符串
+ CHAR ： 用于存储定长字符串（当存储CHAR值时，MySQL会删除所有的末尾空格，但实际查询或使用时空格还在，这个在使用时要注意实测）

+ 定长的CHAR类型不容易产生碎片。

+ BINARY/VARBINARY： 类比于CHAR和VARCHAR，他们存储的是二进制字符串，存储的是字节码而不是字符。

+ TINYTEST, SMALLTEXT, TEXT, MEDIUMTEXT, BIGTEXT : 字符
+ TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, BIGBLOB : ERJINZHI 
+ MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的前max_sort_length字节而不是整个字符串做排序。

#### 3.4 枚举类型
+ 内部存储的是整数
+ 排序是按内部存储的整数排序的，而不是定义的字符串进行排序
+ 字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE

```
mysql> create table enum_test(
    ->   e ENUM('FISH', 'APPLE', 'DOG') NOT NULL
    -> );
Query OK, 0 rows affected (0.02 sec)
```

#### 3.5 日期和时间类型
+ DATETIME: 保存从1001到9999年，精度为秒，它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。
+ TIMESTAMP: 保存了从1970年1月1日午夜以来的秒数，它和UNIX时间戳相同。用4个字节存储，只能表示从1970到2038年。
+ 函数： FROM_UNIXTIME/UNIX_TIMESTAMP

#### 3.6 SET
```
mysql> create table acl(
    ->   perms SET('CAN_READ', 'CAN_WRITE', 'CAN_DELETE') NOT NULL
    -> );
Query OK, 0 rows affected (0.02 sec)

mysql> insert into acl(perms) values ('CAN_READ,CAN_DELETE');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT PERMS FROM ACL WHERE FIND_IN_SET('AN_READ', PERMS);
Empty set (0.00 sec)

mysql> SELECT PERMS FROM ACL WHERE FIND_IN_SET('CAN_READ', PERMS);
+---------------------+
| PERMS               |
+---------------------+
| CAN_READ,CAN_DELETE |
+---------------------+
1 row in set (0.00 sec)

mysql> SELECT PERMS FROM ACL WHERE FIND_IN_SET('CAN_DELETE', PERMS);
+---------------------+
| PERMS               |
+---------------------+
| CAN_READ,CAN_DELETE |
+---------------------+
1 row in set (0.00 sec)

mysql> SELECT PERMS FROM ACL WHERE FIND_IN_SET('CAN_WRITE', PERMS);
Empty set (0.00 sec)

mysql>
```

### 4. 模式设计
#### 范式
+ 在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。
+ 范式化的好处
	- 范式化的更新操作通常要比反范式化的更快
	- 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
	- 范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快。
	- 很少有冗余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。
+ 范式化的缺点： 通常需要表关联

#### 缓存表和汇总表
+ 可以对缓存表使用更合适的存储引擎
+ 要考虑是实时维护数据还是定时重建数据

#### 物化视图实际上是预先计算并存储在磁盘上的表，可以通过各种各样的策略刷新和更新。

#### 计数器表
+ 如果用一行来表示某个属性的计数，则对于任何要更新这个计数的事务来说，都只能串行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。比如：

```
mysql> create table hit_count (
    ->  slot tinyint unsigned not null primary key,
    ->  cnt int unsigned not null
    -> ) ENGINE=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO hit_count(slot, cnt)
    ->      VALUES(RAND()*100, 1)
    ->      ON DUPLICATE KEY UPDATE cnt = cnt +1;
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO hit_count(slot, cnt)
    ->      VALUES(RAND()*100, 1)
    ->      ON DUPLICATE KEY UPDATE cnt = cnt +1;
Query OK, 1 row affected (0.00 sec)

mysql> select sum(cnt) from hit_count;
+----------+
| sum(cnt) |
+----------+
|        2 |
+----------+
1 row in set (0.00 sec)

mysql>
```


