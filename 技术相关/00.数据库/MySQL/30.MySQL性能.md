### 1. 性能总体说明
+ 性能问题定位前，要收集梳理一下服务器的状态、参数配置以及软硬件环境（CPU,内存，磁盘，数据量，软件版本，存储引擎版本等等）
+ 一个性能运维工具要能够
	- 有一个可靠且实时的“触发器”，能够区分什么时候问题出现了。
	- 一个收集诊断数据的工具。 
	+ 要在问题开始时就要捕获数据，如果在问题导致系统快要崩溃时才开始捕获数据，是很难诊断到最初的根本原因的。因为问题通常是持续上升的。
+ 间歇性的问题比如系统偶尔停顿或者慢查询，是相对比较难诊断的。
+ 要确认当前的一个现象是原因还是结果
+ 有两种消耗时间的操作：工作或者等待
+ 优化和提升是两回事，当继续提升的成本超过收益的时候，就要停止优化。

+ 数据库本身可能存在的性能瓶颈点：
	- 内部删除查询换成的算法效率太低导致出现性能问题（之前实际工作中在PG中碰到的存储过程预定义达到阈值淘汰的场景）


### 2. MYSQL提供的一些定位功能
打开慢查询确认慢查询SQL 或者 使用 SHOW FULL PROCESSLIST 命令连续查看，看哪些SQL一直出现
#### 2.1 SHOW PROFILE ：显示查询的每个步骤及耗时
- set profiling = 1
- show profiles
- show profile for query 1

```SQL
mysql> set profiling = 1;
...
mysql> show profiles;
+----------+------------+-------------------------+
| Query_ID | Duration   | Query                   |
+----------+------------+-------------------------+
|        1 | 0.00008500 | show tables             |
|        2 | 0.00012100 | SELECT DATABASE()       |
|        3 | 0.00028600 | show databases          |
|        4 | 0.00017700 | show tables             |
|        5 | 0.00039000 | show tables             |
|        6 | 0.00015800 | select * from time_zone |
|        7 | 0.00451900 | select * from proc      |
+----------+------------+-------------------------+
7 rows in set, 1 warning (0.00 sec)

mysql> show profile for query 2;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000053 |
| checking permissions | 0.000007 |
| Opening tables       | 0.000005 |
| init                 | 0.000009 |
| optimizing           | 0.000006 |
| executing            | 0.000007 |
| end                  | 0.000003 |
| query end            | 0.000004 |
| closing tables       | 0.000003 |
| freeing items        | 0.000013 |
| cleaning up          | 0.000011 |
+----------------------+----------+
11 rows in set, 1 warning (0.00 sec)

mysql>
```

#### 2.2 SHOW STATUS
+ 返回了一些计数器。既有服务器级别的全局计数器，也有会话级别的计数器。
+ 如果执行```SHOW GLOBAL STATUS```则可以查看服务器级别的从服务器启动开始计算的查询次数统计。
+ EXPLAIN是通过估计得到的结果，而通过计数器获得的结果是实际的测量结果。
+ 以较高的频率执行该命令捕获数据，然后观察几个计数器的变化趋势（比如Threads_running, Threads_connected, Questions, Queries等）的尖刺或凹陷来发现异常点。
+ 

```
mysql> show status where Variable_name like 'Created%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Created_tmp_disk_tables | 0     |
| Created_tmp_files       | 5     |
| Created_tmp_tables      | 6     |
+-------------------------+-------+
3 rows in set (0.00 sec)

```

#### 2.3 SHOW PROCESSLIST
+ 通过State信息查看现场状态

```
mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
     Id: 22
   User: root
   Host: localhost
     db: mysql
Command: Query
   Time: 0
  State: starting
   Info: SHOW PROCESSLIST
1 row in set (0.00 sec)

mysql>
```

#### 2.4 慢查询日志
+ 通过慢查询日志确认每秒执行的sql数量
+ 查询是在完成阶段才写入日志的，堆积会造成大量查询处于完成阶段，直到阻塞其他查询的资源占用者释放资源后，其他的查询才能执行完成，这种行为特征的一个好处是：当遇到吞吐量突然下降时，可以归咎于吞吐量下降后完成的第一个查询（也不尽然）

参考：  
http://www.cnblogs.com/luyucheng/p/6265594.html  
http://www.cnblogs.com/luyucheng/p/6265873.html  


设置步骤： 
show variables like 'slow_query%';
show variables like 'long_query_time';

set global slow_query_log='ON'; 
set global slow_query_log_file='/usr/local/mysql/data/slow.log';
set global long_query_time=1;

#### 2.5 参数
+ long_query_time :可以通过设置这个参数为0来捕获所有的查询。