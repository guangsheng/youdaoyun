## 锁类型
---行级锁和表级锁  
---共享锁和排他锁  
---意图锁定是表锁定  

+ 共享的(S)锁允许一个事务去读一行（tuple）。 
+ 独占的锁(X)允许一个事务更新或删除一行。
+ 意图共享(IS)：事务T 意图给表T上单独的tuple设置S 锁定。 
+ 意图独占(IX)：事务T 意图给这些tuple设置X 锁定。
意图锁协议
+ 在假设的事务可以获得对某假定行的S 锁定之前，它必须首先获得对包含该行的表的一个IS 或者更强的锁定。 
+ 在假设的事务可以获得对某假定行的X 锁定之前，它必须首先获得对包含该行的表的一个IX 锁定。

## 事务隔离级别
```
transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED
                         | REPEATABLE-READ | SERIALIZABLE}
```
用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别。它的语法如下：  
``` 
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL
                       {READ UNCOMMITTED | READ COMMITTED
                        | REPEATABLE READ | SERIALIZABLE}
SELECT @@global.tx_isolation;
SELECT @@tx_isolation;
```

**读已提交是PostgreSQL的默认隔离级别，可重复读是mysql的默认隔离级别。**

### 读已提交和可重复读的区别
重复读事务中的查询看到的是事务开始时的快照， 而不是该事务内部当前查询开始时的快照，这样， 单个事务内部的SELECT命令总是看到同样的数据，也就是说，它们看不到 它们自身事务开始之后提交的其他事务所做出的改变

### MySQL的Next-Key锁定
A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.  
实验数据如下（PostgreSQL不是这样实现的，应该是PG的MVCC实现原理和MySQL有差别）:  
```
create table t 
(
    a int primary key,
    b int
) engine=innodb;

create index inx_t_b on t(b);

insert into t select 1,10;
insert into t select 2,10;
insert into t select 3,20;
insert into t select 4,20;
insert into t select 5,30;
insert into t select 6,30;

commit;
```
假设锁定读语句为:  
```update t set b=-1 where b=10;```  
可供锁定的范围为  
(-无穷,10] (10,20] (20,30] (30,+无穷]  
InnoDB会使用Next-Key Locking锁定(-无穷,10]、辅助索引两个b=10的节点和聚簇索引的1、2节点, 并且对辅助索引下一个键值加上gap lock，范围(10,20)  这样，保证了锁定读的可重复读。  

此时，如果在另一终端输入语句:  
```update t set b= -10 where b=30;```  
会导致阻塞。 因为虽然b=30在锁定范围之外，但是set中的b=-10却在锁定范围之内,所以被阻塞。  
如果这个语句没有被阻塞而顺利提交，则最开始的终端,再次查询会发现多出两条记录(5,-10)和(6,-10).出现了幻读。  

不可重复读的重点是修改:  
同样的条件, 你读取过的数据, 再次读取出来发现值不一样了  

幻读的重点在于新增或者删除  
同样的条件, 第1次和第2次读出来的记录数不一样  

### 可重复读
如果你没有适合查询的索引，MySQL不得不扫描整个表来处理查询，表的每行变成被锁定的，这样反过来阻止其它用户的所有对表的插入。创建一个好的索引让你的查询不必要扫描很多行是很重要的。

### 锁定相关
+ ```SELECT ... FROM ... LOCK IN SHARE MODE```对读遇到的所有索引记录设置共享的next-key锁定。  
+ ```SELECT ... FROM ... FOR UPDATE```对读遇到的所有索引记录设置独占的next-key锁定。  
+ ```INSERT INTO ... VALUES (...)```对被插入的行设置独占锁定。注意，这不是一个next-key锁定，并且不阻止其它用户在已插入行之前的间隙插入。如果发生重复键错误，对重复的索引记录设置共享锁定。  
+ ```UPDATE ... WHERE ...``` 对搜索遇到的每个记录设置一个独占的next-key锁定。  
+ ```DELETE FROM ... WHERE ...``` 对搜索遇到的每个记录设置一个独占的next-key锁定。  
+ ```INSERT INTO T SELECT ... FROM S WHERE ...``` 对每个插入到T的行设置独占（非next-key）锁定。它在S上把搜索当作一个持续读，但是如果MySQL二进制日志功能被打开，它就对S设置一个共享的next-key锁定。  
+ ```LOCK TABLES```设置表锁定，但是是InnoDB层之上更高的MySQL层设置这些锁定。  

### 隐式提交
下列每一个语句（以及它们的任何同义词）隐式结束一个事务，就好像在执行这个语句之前你做了一个COMMIT：   
+ ALTER FUNCTION, ALTER PROCEDURE, ALTER TABLE, BEGIN, CREATE DATABASE, CREATE FUNCTION, CREATE INDEX, CREATE PROCEDURE, CREATE TABLE, DROP DATABASE, DROP FUNCTION, DROP INDEX, DROP PROCEDURE, DROP TABLE, LOAD MASTER DATA, LOCK TABLES, RENAME TABLE, SET AUTOCOMMIT=1, START TRANSACTION, TRUNCATE, UNLOCK TABLES. 
+ UNLOCK TABLES 仅在如果任何表当前被锁定之时，提交一个事务。 
+ 在InnoDB中的CREATE TABLE语句被作为一个单独的事务来处理。这意味着来自用户的ROLLBACK不撤销用户在事务过程中生成的CREATE TABLE语句。 
+ 事务不能被嵌套。当你发出START TRANSACTION语句或与之同义的语句之时，这是对任何当前事务 隐式提交的一个结果。

