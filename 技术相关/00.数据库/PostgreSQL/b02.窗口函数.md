## 参考文档
https://blog.csdn.net/mzl87/article/details/84455076

### 1、窗口函数的描述
窗口函数作用于一个数据行集合。窗口是标准的SQL术语，用来描述SQL语句内OVER子句划定的内容，这个内容就是窗口函数的作用域。而在OVER子句中，定义了窗口所覆盖的与当前行相关的数据行集、行的排序及其他的相关元素。

标准SQL对窗口函数的第一次支持是在SQL:1999的扩展文档中，当时，它们称为“OLAP”函数。从那以后，每次标准版本的修订都会增强对窗口函数的支持，直到现在的SQL:2003、SQL:2008、SQL:2011。最新的SQL标准版本，已经有了非常丰富和全面的窗口函数，显示出标准委员会对这一概念的坚定，以及从更多窗口函数和更多功能两个方面持续增强支持标准。

### 2、窗口函数中的元素
窗口函数的行为描述出现在函数的OVER子句中，并涉及多个元素。3个核心元素分别是分区、排序和框架。不是所有的窗口函数都支持这3个元素。

#### 2.1、分区
分区元素是由**PARTITION BY**子句定义，并被所有的窗口函数支持。他对当前计算的窗口函数进行限制，**仅仅那些在结果集的分区列中与当前行有相同值的行才能进入窗口**。如果没有指定PARTITION BY子句，窗口就没有限制。换种说法就是：如果没有显示指定分区，则默认分区就是把整个查询结果集当作一个分区。有一点不太明显，这里提出来：同一个查询中的不同函数，可能会有不同的分区描述。

#### 2.2、排序
排序元素定义计算的顺序，如果与分区有关，则是在分区内的顺序。在标准的SQL中，所有函数都支持排序元素。起初SQL SERVER不支持聚合函数中的排序元素，而仅仅支持分区。对聚合函数红排序的支持，是从SQL SERVER 2012 开始的。

有趣的是，针对不同的函数类别，排序元素有轻微的不同意义。对于排名函数，排序是直观的。而聚合窗口函数的排序和排名窗口的排序略有意义上的不同。在聚合中，与某些人认为的相反，排序与聚合的顺序无关；然而，排序元素为下面将描述的框架选项赋予一定的含义，换句话说，排序元素帮助限定在窗口内的行。

#### 2.3、框架
从本质上来说，框架是一个在分区内对行进行进一步限制的筛选器。它适用于聚合窗口函数，也适用于三个偏移函数：```FIRST_VALUE、LAST_VALUE、NTH_VALUE```。把这个窗口元素想成是基于给定的排序，在当前行所在分区中定义两个点，这两个点形成的框架之间的行才会参与计算。

在标准的框架描述中，包含一个ROWS或RANGE选项，用来定义框架的开始行和结束行，这两行也可以形成“框架外”（框架内的行被排除在计算外）窗口选项。SQL SERVER 2012 开始支持框架，完全实现ROWS选项，部分实现RANGE选项，尚未实现“框架外”窗口选项。

ROWS选项允许我们用相对当前行的偏移行数来指定框架的起点和终点。RANGE选项更具灵活性，可以以框架起终点的值于当前行的值的差异来定义偏移行数。“框架外”窗口选项用来定义如何对当前行及具有相同值的行进行处置。


### 3、支持窗口函数的查询元素
并不是所有的查询子句都支持窗口函数，相反，仅仅SELECT和ORDER BY 子句支持窗口函数。为帮助理解，我们先看看SQL不同子句的执行顺序：

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
    - 5.1. Evalute Expressions（判断表达式）
    - 5.2. 删除重复数据
6. ORDER BY
7. OFFSET-FETCH/TOP

只有SELECT和ORDER BY 子句直接支持窗口函数。做这个限制的原因是为了避免二义性，**因此把查询的最终结果当作窗口的起点**。如果窗口函数可以早于SELECT阶段出现，那么通过一些查询表单会无法得到正确的结果。

### 4、窗口函数类别
窗口函数分为排名函数、分布函数、偏移函数等。

#### 4.1、排名函数
SQL标准支持4种用于排名计算的窗口函数。它们是：ROW_NUMBER、NTILE、RANK和DENSE_RANK。在标准中，前两者是一类，后两者是另一类。

- ROW_NUMBER函数根据指定的顺序，从1开始计算连续的行号。
- NTILE函数把窗口分区里的数据行分成数量大致相等的块（根据输入的块数和指定的窗口排序）。

注意：为避免有人认为分块和分页相似，这里提醒大家，不要把二者混淆起来。在分页中，页的大小是常量，并且页码是动态的——查询结果集除以页面大小后得到的数值。而分块中，块的数量是常量，块的大小是动态的——行的数量除以设定的块的数量后得到的数值。分页在何处使用是很明显的，分块通常用于分析目的——那些需要涉及基于某种衡量顺序，把数据分到预先设定的固定数量、相同大小的桶(bucket)中。

- RANK（排名）和DENSE_RANK（密集排名）函数的计算和ROW_NUMBER函数类似，唯一不同的是，它们在窗口分区内生成的值不必是唯一的。当窗口排序方向是升序时，RANK函数计算分区内排序值比当前行小的行的数量，在次数量上加1，就是当前行的排名；DENSE_RANK函数计算分区内相异的（distinct）排序值比当前行小的行的数量，在此数量上加1，就是当前行的排名。当窗口排序方向是降序时，RANK函数计算分区内排序属性比当前行大的行的数量，在此数量上加1，就是当前行的排名；DENSE_RANK函数计算分区内相异的（distinct）排序值比当前行大的行的数量，在此数量上加1，就是当前行的排名。

#### 4.2、分布函数
窗口分布函数主要为静态统计服务提供数据的分布情况。SQL Server 2012引入了两种窗口分布函数的支持：排名分布函数和逆分布函数。排名分布函数有两种：PERCENT_RANK(百分位排名)和CUME_DIST(累积分布)，逆分布函数也有两个：PERCENT_CONT（百分位连续）和PERCENTILE_DISC（百分位离散）。

根据标准SQL，分布函数计算数据行在窗口分区中的相对排名，把它表达成介于0~1之间的比值——我们大多数人把它看做百分比。

假设rk 为数据行的RANK值，RANK函数的窗口描述与分布函数的窗口描述相同。假设nr为窗口分区内数据行的行数。假设np为领先或与当前行的排序值相同的行的数目（为比当前rk减1大的最小rk值，如果当前的rk为最大值，np则等于nr）。

PERCENT_RANK(百分位排名)计算公式如下：(rk-1)/(nr-1),PERCENT_RANK(百分位排名)的计算公式如下：np/nr。

逆分布函数，通常叫百分位，我们可以把它执行的计算当作是排名分布函数的倒数。

PERCENTILE_DISC（百分位离散）函数（DISC为离散分布模型）返回组中第一个符合条件的值，条件是：其累计分布（CUME_DIST函数）大于等于输入值。

PERCENT_CONT（百分位连续）函数（CONT为连续分布函数）比较难理解（PERCENT_CONT（@pct） WITHIN GROUP(ORDER BY 分数)）。举个简单示例，想象对一行数为偶数的组进行中值计算。我们需要内插值来支持连续分布假定，插入的值落在两个中间点的中间，意味着它是两个中间点的平均值。

#### 4.3、偏移函数
窗口偏移函数包括两种类型的函数。一种是偏移量是相对于当前行的，这个类别的包括LAG和LEAD函数；另一个类别函数的偏移量是相对于窗口框架的开始和结尾的，这个类别包括FIRST_VALUE、LAST_VALUE和NTH_VALUE。第一类别中的函数（LAG和LEAD）支持窗口分区子句以及窗口排序子句。当然，后者的存在赋予偏移量以逻辑意义。第二类别中的函数（FIRST_VALUE、LAST_VALUE和NTH_VALUE）在支持窗口分区子句和排序子句的基础上，还支持窗口框架子句。

LAG和LEAD函数允许我们从窗口分区中，根据给定的相对于当前行的前偏移量（LAG）和后偏移量（LEAD），返回对应行的值。如果没有指定，偏移量默认为1。

FIRST_VALUE和FIRST_VALUE分别返回框架的第一行和最后一行所有查询的值。NTH_VALUE函数作用是中的相对窗口框架第一行或最后一行的偏移量，使得我们可以取得对应这个偏移量的记录值。

--------------------- 
作者：mzl87   
来源：CSDN   
原文：https://blog.csdn.net/mzl87/article/details/84455076   
版权声明：本文为博主原创文章，转载请附上博文链接！  

## 概念说明
**窗口函数在和当前行相关的一组表行上执行计算。 这相当于一个可以由聚合函数完成的计算类型。但不同于常规的聚合函数， 使用的窗口函数不会导致行被分组到一个单一的输出行；行保留其独立的身份。 在后台，窗口函数能够访问的不止查询结果的当前行。**

- SQL window functions（SQL 窗口函数）
- 窗口函数作用于一个数据行集合。
- The over clause defines which rows are visible to a window function. OVER子句划定的内容，这个内容就是窗口函数的作用域
- 3个核心元素分别是分区(PARTITION BY)、排序(ORDER BY)和框架(ROW_NUMBER, RANK, LEAD, LAG等)
- 所谓框架
  - 排名函数：row_number, rank, cume_dist, ntile
  - 分布函数: dense_rank, percent_rank
  - 偏移函数: lag, lead, first_value, last_value, nth_value

## 实例说明
### 查询结果列中同时输出详情和总数
```
--输出名称、类型和总数
store_mix=# select relname, relkind, count(*) over() from pg_class limit 10;
             relname             | relkind | count
---------------------------------+---------+-------
 pg_statistic                    | r       |   360
 pg_type                         | r       |   360
 pg_toast_20614                  | t       |   360
 pg_toast_20614_index            | i       |   360
 pk_bike_sms                     | i       |   360
 pg_toast_2619                   | t       |   360
 pg_toast_2619_index             | i       |   360
 pg_authid_rolname_index         | i       |   360
 pg_authid_oid_index             | i       |   360
 pg_attribute_relid_attnam_index | i       |   360
(10 rows)

--输出名称、类型和对应当前类型的总数
store_mix=# select relname, relkind, count(*) over(partition by relkind) from pg_class limit 10;
             relname             | relkind | count
---------------------------------+---------+-------
 pg_type_oid_index               | i       |   152
 pg_toast_20614_index            | i       |   152
 pk_bike_sms                     | i       |   152
 pg_toast_2619_index             | i       |   152
 pg_authid_rolname_index         | i       |   152
 pg_authid_oid_index             | i       |   152
 pg_attribute_relid_attnam_index | i       |   152
 pg_attribute_relid_attnum_index | i       |   152
 pg_toast_1255_index             | i       |   152
 pg_toast_2604_index             | i       |   152
(10 rows)
```

### 输出明细及本行和下一行的差值
```
store_mix=# select relname, relnatts, relnatts - lead(relnatts) over() as minusnatts from pg_class limit 10;
             relname             | relnatts | minusnatts
---------------------------------+----------+------------
 pg_statistic                    |       26 |         -4
 pg_type                         |       30 |         27
 pg_toast_20614                  |        3 |          1
 pg_toast_20614_index            |        2 |          1
 pk_bike_sms                     |        1 |         -2
 pg_toast_2619                   |        3 |          1
 pg_toast_2619_index             |        2 |          1
 pg_authid_rolname_index         |        1 |          0
 pg_authid_oid_index             |        1 |         -1
 pg_attribute_relid_attnam_index |        2 |          0
(10 rows)

--按数值降序并输出数值的差值
store_mix=# select relname, relnatts, relnatts - lead(relnatts) over(order by relnatts desc) as minusnatts from pg_class limit 10;
      relname       | relnatts | minusnatts
--------------------+----------+------------
 routines           |       82 |         38
 columns            |       44 |         12
 parameters         |       32 |          1
 attributes         |       31 |          1
 pg_am              |       30 |          0
 pg_type            |       30 |          1
 element_types      |       29 |          0
 user_defined_types |       29 |          0
 pg_class           |       29 |          2
 domains            |       27 |          0
(10 rows)

```
### 输出指定的排序值
```
store_mix=# select relname, relnatts, relnatts - lead(relnatts) over(order by relnatts desc) as minusnatts , first_value(relnatts) over(), last_value(relnatts) over(), nth_value(relnatts, 4) over() from pg_class limit 10;
      relname       | relnatts | minusnatts | first_value | last_value | nth_value
--------------------+----------+------------+-------------+------------+-----------
 routines           |       82 |         38 |          82 |          1 |        31
 columns            |       44 |         12 |          82 |          1 |        31
 parameters         |       32 |          1 |          82 |          1 |        31
 attributes         |       31 |          1 |          82 |          1 |        31
 pg_am              |       30 |          0 |          82 |          1 |        31
 pg_type            |       30 |          1 |          82 |          1 |        31
 element_types      |       29 |          0 |          82 |          1 |        31
 user_defined_types |       29 |          0 |          82 |          1 |        31
 pg_class           |       29 |          2 |          82 |          1 |        31
 domains            |       27 |          0 |          82 |          1 |        31
(10 rows)

--是先得到记录再计算
store_mix=# select relname, relnatts,first_value(relnatts) over(), last_value(relnatts) over(), nth_value(relnatts, 4) over() from pg_class limit 10;
             relname             | relnatts | first_value | last_value | nth_value
---------------------------------+----------+-------------+------------+-----------
 pg_statistic                    |       26 |          26 |          1 |         2
 pg_type                         |       30 |          26 |          1 |         2
 pg_toast_20614                  |        3 |          26 |          1 |         2
 pg_toast_20614_index            |        2 |          26 |          1 |         2
 pk_bike_sms                     |        1 |          26 |          1 |         2
 pg_toast_2619                   |        3 |          26 |          1 |         2
 pg_toast_2619_index             |        2 |          26 |          1 |         2
 pg_authid_rolname_index         |        1 |          26 |          1 |         2
 pg_authid_oid_index             |        1 |          26 |          1 |         2
 pg_attribute_relid_attnam_index |        2 |          26 |          1 |         2
(10 rows)

```

### 窗口求和
```
store_mix=# select  relname, relnatts, sum(relnatts) over() from pg_class limit 10;
             relname             | relnatts | sum
---------------------------------+----------+------
 pg_statistic                    |       26 | 2099
 pg_type                         |       30 | 2099
 pg_toast_20614                  |        3 | 2099
 pg_toast_20614_index            |        2 | 2099
 pk_bike_sms                     |        1 | 2099
 pg_toast_2619                   |        3 | 2099
 pg_toast_2619_index             |        2 | 2099
 pg_authid_rolname_index         |        1 | 2099
 pg_authid_oid_index             |        1 | 2099
 pg_attribute_relid_attnam_index |        2 | 2099
(10 rows)

store_mix=# select  relname, relnatts, sum(relnatts) over(order by relnatts desc) from pg_class limit 10;
      relname       | relnatts | sum
--------------------+----------+-----
 routines           |       82 |  82
 columns            |       44 | 126
 parameters         |       32 | 158
 attributes         |       31 | 189
 pg_am              |       30 | 249
 pg_type            |       30 | 249
 element_types      |       29 | 336
 user_defined_types |       29 | 336
 pg_class           |       29 | 336
 domains            |       27 | 390
(10 rows)
```

### 排序
```
store_mix=# select  relname, relnatts, rank() over(order by relnatts desc) from pg_class limit 10;
      relname       | relnatts | rank
--------------------+----------+------
 routines           |       82 |    1
 columns            |       44 |    2
 parameters         |       32 |    3
 attributes         |       31 |    4
 pg_am              |       30 |    5
 pg_type            |       30 |    5
 element_types      |       29 |    7
 user_defined_types |       29 |    7
 pg_class           |       29 |    7
 domains            |       27 |   10
(10 rows)

store_mix=# select  relname, relnatts,row_number() over(order by relnatts desc) from pg_class limit 10;
      relname       | relnatts | row_number
--------------------+----------+------------
 routines           |       82 |          1
 columns            |       44 |          2
 parameters         |       32 |          3
 attributes         |       31 |          4
 pg_am              |       30 |          5
 pg_type            |       30 |          6
 element_types      |       29 |          7
 user_defined_types |       29 |          8
 pg_class           |       29 |          9
 domains            |       27 |         10
(10 rows)
```


### 分布
```
store_mix=# select  relname, relnatts,percent_rank() over(order by relnatts desc) from pg_class limit 10;
      relname       | relnatts |    percent_rank
--------------------+----------+---------------------
 routines           |       82 |                   0
 columns            |       44 | 0.00278551532033426
 parameters         |       32 | 0.00557103064066852
 attributes         |       31 | 0.00835654596100279
 pg_am              |       30 |   0.011142061281337
 pg_type            |       30 |   0.011142061281337
 element_types      |       29 |  0.0167130919220056
 user_defined_types |       29 |  0.0167130919220056
 pg_class           |       29 |  0.0167130919220056
 domains            |       27 |  0.0250696378830084
(10 rows)

store_mix=# select  relname, relnatts, dense_rank() over(order by relnatts desc) from pg_class limit 10;
      relname       | relnatts | dense_rank
--------------------+----------+------------
 routines           |       82 |          1
 columns            |       44 |          2
 parameters         |       32 |          3
 attributes         |       31 |          4
 pg_am              |       30 |          5
 pg_type            |       30 |          5
 element_types      |       29 |          6
 user_defined_types |       29 |          6
 pg_class           |       29 |          6
 domains            |       27 |          7
(10 rows)

store_mix=#
```

```
pg_attribute, pg_class
主机名(attrelid)
告警数(count(*))
团队(pg_class.relnamespace)

--查询出各个模式下列数量排名前三的表
select * from (
with temp_table as(
select pc.relname, pc.relnamespace, count(*) as num
  from pg_class pc, pg_attribute pa
 where pc.oid = pa.attrelid
 group by pc.relname, pc.relnamespace)
select relname, relnamespace, num, row_number() over(partition by relnamespace order by num desc) as order_no from temp_table) as b
 where order_no <= 3;
```