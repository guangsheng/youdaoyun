测试环境主用备用在同一台机器上  

主用：  /dbdir/postgresql/postgres10/5433/data 
备用：  /dbdir/postgresql/postgres10/5434/data  

### 一、基本配置参数
#### postgresql.conf主备用配置
```
logging_collector = on
log_min_messages = notice
log_min_duration_statement = 1000
log_checkpoints = on
log_connections = on
log_disconnections = on
log_duration = on
log_error_verbosity = verbose
log_line_prefix = '%t [%p]: [%l-1] <%d %u %h>'

unix_socket_permissions = 0600

listen_addresses = '*'
max_wal_senders = 3 
wal_level = replica
archive_mode = on 
archive_command = 'cd ./'
hot_standby = on

```

#### postgresql.conf主用配置
```
port = 5433
```

#### postgresql.conf备用配置
```
port = 5434
```

#### recovery.conf备用配置（主用可以配置也可以不配，和备用差别就是IP和端口号）
```
recovery_target_timeline = 'latest'
standby_mode = on
primary_conninfo = 'host=10.111.50.227 port=5433 user=repuser'
```

### 二、初始化双机步骤
前提： 主用和备用数据库程序都已经安装且已经执行过initdb
#### 1. 修改主用数据库参数配置
```
#修改
cp postgresql.conf postgresql.conf.bak
cd /dbdir/postgresql/postgres10/5433/data
TMPDATA="/dbdir/postgresql/postgres10/5433/data"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 1 -p log_line_prefix -v "%t [%p]: [%l-1] <%d %u %h>"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 1 -p listen_addresses -v "*"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p unix_socket_permissions -v "0600"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_error_verbosity -v "verbose"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p logging_collector -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_min_messages -v "notice"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_min_duration_statement -v "1000"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_checkpoints -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_connections -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_disconnections -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p log_duration -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p archive_mode -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p hot_standby -v "on"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p wal_level -v "replica"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p max_wal_senders -v "3"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 0 -p port -v "5433"
bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${TMPDATA} -t 1 -p archive_command -v "cd .\/"

#检查
diff postgresql.conf postgresql.conf.bak 
```
#### 2. 启动主用数据库
```
pg_ctl start -D /dbdir/postgresql/postgres10/5433/data
```

#### 3. 创建流复制用户并配置pg_hba.conf/recovery.conf
```
CREATE USER repuser replication LOGIN CONNECTION LIMIT 3 ENCRYPTED PASSWORD 'repuser';
```

##### 主用pg_hba.conf  配备用IP
```
masterPGDATA="/dbdir/postgresql/postgres10/5433/data/"
cd "$masterPGDATA"
echo "host    replication     repuser       10.111.50.227/32       trust" >> pg_hba.conf
pg_ctl reload -D ${masterPGDATA}
```

#### 4. 使用pg_basebackup创建备库: 在slave端数据库用户下执行
```
slavePGDATA="/dbdir/postgresql/postgres10/5434/data"
masterPort="5433"
masterIP="10.111.50.227"
cd $slavePGDATA
rm -rf *
## 保证主备目录结构完全一致或者主用数据库没有改变xlog目录且不存在data外的表空间目录
pg_basebackup -D "$slavePGDATA" -Fp -Xs -v -P -h "$masterIP" -p "$masterPort" -U repuser
```

#### 5. 修改备用端口号，pg_hba.conf文件和创建备用recovery.conf
```
cd "$slavePGDATA"
echo "host    replication     repuser       10.111.50.227/32       trust" >> pg_hba.conf

echo "recovery_target_timeline = 'latest'" > recovery.conf
echo "standby_mode = on"  >> recovery.conf
echo "primary_conninfo = 'host=10.111.50.227 port=5433 user=repuser'" >> recovery.conf
chmod 600 recovery.conf

bash /dbdir/pg_custom_tool/hellobike_pgfuncs.sh -b setconfig -D ${slavePGDATA} -t 0 -p port -v "5434"
```

#### 6. 启动备用数据库
```
pg_ctl start -D ${slavePGDATA}
```
#### 7. 测试是否能够同步
可以通过如下几种方式初步确认双机同步状态  
主用是否有```postgres: wal sender process repuser``` 进程  
备用是否有```postgres: wal receiver process   streaming 0/3000140 ```进程  
或在主用数据库查看表 ```pg_stat_replication``` 中是否有记录  
或使用函数```select pg_is_in_recovery();```查看（备用为t，主用为f）    
或使用```pg_controldata```命令查看返回信息中Database cluster state对应的值  

```
ps -ef |grep wal |grep process
pg_controldata -D ${masterPGDATA} |grep "Database cluster state"

select * from pg_stat_replication;
select pg_is_in_recovery();
```

### 三、新建备机
从**二、初始化双机步骤**的第4步开始操作即可

### 四、平滑倒换
流程：先停掉应用（或者可以停掉对外提供服务的IP端口）--> 杀掉当前存活的数据库服务进程 --> 等待主备同步完成 --> 停止主用机器，并生成recovery.conf --> 备用升主 --> 启动主用 --> 检查双机状态 --> 开放对外连接

#### 1. 杀掉当前存活的数据库服务进程 --master端操作
```
for pid in select pid from pg_stat_activity where pid != pg_backend_pid() :
    select pg_terminate_backend(:pid);
end for;
```
#### 2. 等待主备同步完成 --master端操作
```
check  --低版本对应函数是pg_xlog_location_diff和pg_current_xlog_location
select client_addr, pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) as diff from pg_stat_replication;
```
#### 3. 停止主用机器，并生成recovery.conf --master端操作
```
masterPGDATA="/dbdir/postgresql/postgres10/5433/data/"
pg_ctl stop -D ${masterPGDATA}

cd ${masterPGDATA}
rm recovery.conf
echo "recovery_target_timeline = 'latest'" > recovery.conf
echo "standby_mode = on"  >> recovery.conf
echo "primary_conninfo = 'host=10.111.50.227 port=5434 user=repuser'" >> recovery.conf
chmod 600 recovery.conf
```

#### 4. 备用升主 --备用端操作
```
slavePGDATA="/dbdir/postgresql/postgres10/5434/data/"
pg_ctl promote -D ${slavePGDATA}
```
#### 5. 启动主用
```
masterPGDATA="/dbdir/postgresql/postgres10/5433/data/"
pg_ctl start -D ${masterPGDATA}
```
如果启动时报如下类似错误（通常出现在备升主时，主用并未停止的场景）：  
ERROR:  requested starting point 0/6000000 on timeline 1 is not in this server's history  
DETAIL:  This server's history forked from timeline 1 at 0/4000098.  

需要执行使用pg_rewind命令修复  

```
pg_rewind  --target-pgdata=new_slave_pgdata --source-server='host=new_maste_ip port=new_master_port user=superuser dbname=postgres' -P --debug
```
pg_rewind 前提条件  
1. ```full_page_writes```设置为on  
2. ```wal_log_hints```设置为on  

#### 6. 检查双机状态
可以通过如下几种方式初步确认双机同步状态  
主用是否有```postgres: wal sender process repuser``` 进程  
备用是否有```postgres: wal receiver process   streaming 0/3000140 ```进程  
或在主用数据库查看表 ```pg_stat_replication``` 中是否有记录  
或使用函数```select pg_is_in_recovery();```查看（备用为t，主用为f）    
或使用```pg_controldata```命令查看返回信息中Database cluster state对应的值


### 五、备机强制升主
**四、平滑倒换**的备用升主步骤，不过要做些保护防止出现双主的情况。

### 六、其他
- pg_basebackup不止可以从主机备份还可以从备机备份。要从备机备份， 设置备机以使其可以接受复制连接（也就是，设置max_wal_senders 和 hot_standby，并且配置host-based authentication）。 也需要在主机上启用full_page_writes。
- 重建就是重新搭建备机