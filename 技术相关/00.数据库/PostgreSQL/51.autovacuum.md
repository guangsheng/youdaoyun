### 参数
```
postgres=# select name, setting from pg_settings where name like '%vacuum%';
                name                 |  setting
-------------------------------------+-----------
 autovacuum                          | on
 autovacuum_analyze_scale_factor     | 0.1
 autovacuum_analyze_threshold        | 50
 autovacuum_freeze_max_age           | 200000000
 autovacuum_max_workers              | 3
 autovacuum_multixact_freeze_max_age | 400000000
 autovacuum_naptime                  | 60
 autovacuum_vacuum_cost_delay        | 20
 autovacuum_vacuum_cost_limit        | -1
 autovacuum_vacuum_scale_factor      | 0.2
 autovacuum_vacuum_threshold         | 50
 autovacuum_work_mem                 | -1
 log_autovacuum_min_duration         | -1
 vacuum_cost_delay                   | 0
 vacuum_cost_limit                   | 200
 vacuum_cost_page_dirty              | 20
 vacuum_cost_page_hit                | 1
 vacuum_cost_page_miss               | 10
 vacuum_defer_cleanup_age            | 0
 vacuum_freeze_min_age               | 50000000
 vacuum_freeze_table_age             | 150000000
 vacuum_multixact_freeze_min_age     | 5000000
 vacuum_multixact_freeze_table_age   | 150000000
(23 rows)
```

### 说明
- ```autovacuum_analyze_scale_factor```
- ```autovacuum_analyze_threshold```
- ```autovacuum_vacuum_scale_factor```
- ```autovacuum_vacuum_threshold```  
    当threshold+dead_tuples >= factor*reltuples时启动auto analyze或auto vacuum
- ```autovacuum_vacuum_cost_delay```
- ```autovacuum_vacuum_cost_limit``` 
- ```vacuum_cost_delay```
- ```vacuum_cost_limit```  
	如果积累的开销达到了limit声明的限制， 那么执行这个操作的进程将睡眠delay指定的时间  
	开销是PostgreSQL内部的一个算法来计数的
- ```vacuum_cost_page_dirty``` : 清理修改一个原先是干净的块的预计开销
- ```vacuum_cost_page_hit``` : 清理一个在共享缓存里找到的缓冲区的预计开销
- ```vacuum_cost_page_miss``` : 清理一个要从磁盘上读取的缓冲区的预计开销
- ```autovacuum_freeze_max_age```  
- ```autovacuum_multixact_freeze_max_age```  
- ```vacuum_freeze_min_age```
- ```vacuum_freeze_table_age```  
    表在清理之前允许执行的最大事务次数 是20亿事务减去VACUUM上次扫描整个表时的vacuum_freeze_min_age值。 如果超过这个限制就很可能造成数据丢失。为了保证数据安全， 必须在任何可能包含旧于autovacuum_freeze_max_age指定的XID的未冻结行的 表上调用autovacuum。甚至在autovacuum被禁用的情况下也可以调用。
- ```autovacuum_naptime``` : 启动autovacuum worker的间隔时间
- ```log_autovacuum_min_duration``` : -1不记录日志，
- ```vacuum_defer_cleanup_age```  
    流复制相关，指定由VACUUM和 HOT更新的事务数将延迟死行版本的清理。 该默认值是零事务，这意味着死行版本可以尽快删除， 也就是说，只要他们不再可见于任何打开的事务。 你不妨将它设置为一个支持双机热备的主服务器上的非零值， 正如第 25.5 节所描述的。 这需要更多的时间完成待机状态的查询，由于行早期清除而不会产生冲突。 然而，因为该值是依据发生在主服务器上的写入事务数量进行计算， 它是很难预测到底有多少额外的宽限时间将提供给备用查询。 这个参数只能在postgresql.conf 文件或服务器命令行上设置。