### 了解
1. 创建主表
2. 创建子表（继承自主表，要指定约束和重新创建索引、主键等） 说明：继承不会继承索引、约束
3. 创建主表的增删改触发器，将相应的数据改为处理对应子表

```sql
--创建表和约束  
create table person(id int primary key, name varchar(50), age int, sex int);
create table men ( check(sex = 1)) inherits (person);
create table women (check(sex = 0)) inherits (person);
create unique index men_pk on men (id);
create unique index women_pk on women (id);

--以INSERT为例说明创建触发器方式  
CREATE OR REPLACE FUNCTION person_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.sex = 1 THEN
        INSERT INTO men VALUES (NEW.*);
    ELSE
        INSERT INTO women VALUES (NEW.*);
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER person_insert_trigger
BEFORE INSERT ON person
FOR EACH ROW EXECUTE PROCEDURE person_insert_trigger();

---测试
insert into person values(1,'limin',12,1);
insert into person values(2,'hanmeimei',14,0);
insert into person values(3,'zhuhuayin',15,1);
insert into person values(4,'zhouzheng',16,1);
insert into person values(5,'zhuhuahua',17,0);

test_db=# select * from person;
 id |   name    | age | sex
----+-----------+-----+-----
  1 | limin     |  12 |   1
  3 | zhuhuayin |  15 |   1
  4 | zhouzheng |  16 |   1
  5 | zhuhuahua |  17 |   0
  2 | hanmeimei |  14 |   0
(5 rows)

test_db=# select * from only person;
 id | name | age | sex
----+------+-----+-----
(0 rows)

test_db=# select * from men;
 id |   name    | age | sex
----+-----------+-----+-----
  1 | limin     |  12 |   1
  3 | zhuhuayin |  15 |   1
  4 | zhouzheng |  16 |   1
(3 rows)

test_db=# select * from women;
 id |   name    | age | sex
----+-----------+-----+-----
  5 | zhuhuahua |  17 |   0
  2 | hanmeimei |  14 |   0
(2 rows)

postgres=# update person set name = 'liminmin' where id = 1;
UPDATE 1
postgres=# select * from person;
 id |   name    | age | sex
----+-----------+-----+-----
  3 | zhuhuayin |  15 |   1
  4 | zhouzheng |  16 |   1
  1 | liminmin  |  12 |   1
  2 | hanmeimei |  14 |   0
  5 | zhuhuahua |  17 |   0
(5 rows)

postgres=#
```

### 使用注意事项
#### 分区和约束排除
- 如果没有约束排除，查询会扫描所有的分区表，如果有，则只扫描根据约束排除找出的表。  
- 约束排除只由CHECK约束驱动，而不会由索引驱动。 因此，在关键字字段上定义索引是没有必要的。 在给出的分区上是否需要建立索引取决于那些扫描该分区的查询通常是扫描该分区的一大部分还是只是一小部分。 对于后者，索引通常都有帮助，对于前者则没有什么好处。  
- 约束排除只是在查询的WHERE子句包含常量（或者外部提供的参数）的时候才生效。  
- 主表的所有分区的所有约束在约束排除中被审查，所以大量的分区将大大增加查询规划时间

##### 对于已经分区的表
- 没有办法自动验证所有的CHECK约束是互斥的
- 这里显示的模式假设分区内一行的主字段永远不变，或者至少不变足够要求它移到另一个分区