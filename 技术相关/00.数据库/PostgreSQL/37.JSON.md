#### 基本说明
- 对于JSON字段，gin索引支持@>、?、 ?&和?|四种操作符。
- json 数据类型存储输入文本的精确拷贝，处理函数必须在每个执行上重新解析； 而jsonb数据以分解的二进制格式存储， 这使得它由于添加了转换机制而在输入上稍微慢些，但是在处理上明显更快， 因为不需要重新解析.
- jsonb如果在输入中指定了重复的键，那么只保存最后一个值。
- jsonb拒绝超出PostgreSQL numeric 数据类型范围的数字，而json不拒绝。


#### 操作符
```
操作符	右操作数的类型	描述	示例
@>	jsonb	左侧的JSON值包含右侧的值吗？	'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb
<@	jsonb	左侧的JSON值包含在右侧的值中吗？	'{"b":2}'::jsonb <@ '{"a":1, "b":2}'::jsonb
?	text	测试一个字符串（作为text值给出） 是否作为一个对象键或者数组元素中顶级的jsonb值出现	'{"a":1, "b":2}'::jsonb ? 'b'
?|	text[]	是否存在任一键/元素字符串？	'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']
?&	text[]	是否所有键/元素字符串都存在？	'["a", "b"]'::jsonb ?& array['a', 'b']

操作符	右操作数的类型	描述	示例	示例结果
->	int	获取JSON数组元素（索引从0开始）	'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2	{"c":"baz"}
->	text	通过key获取JSON对象字段	'{"a": {"b":"foo"}}'::json->'a'	{"b":"foo"}
->>	int	获取JSON数组元素为text	'[1,2,3]'::json->>2	3
->>	text	获取JSON对象字段为text	'{"a":1,"b":2}'::json->>'b'	2
#>	text[]	在指定的路径获取JSON对象	'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}'	{"c": "foo"}
#>>	text[]	在指定的路径获取JSON对象为text	'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'	3
```

#### 一些细节
```
bike=> SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;
 ?column?
----------
 t
(1 row)

bike=> SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;
 ?column?
----------
 f
(1 row)

bike=> SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;
 ?column?
----------
 t
(1 row)

---例外
bike=> SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;
 ?column?
----------
 t
(1 row)

bike=>
```

#### 函数
```
函数	描述	示例	示例结果
to_json(anyelement)	作为JSON返回该值。数组和复合被转换（递归的）成数组和对象；另外， 如果有一个转换从该类型到json，则将使用该转换函数执行转换； 否则，产生JSON标量值。对于任意标量类型，除了数字、布尔或空值， 将使用该文本表示，适当的引用和逃逸，使其是一个有效的JSON字符串。	to_json('Fred said "Hi."'::text)	"Fred said \"Hi.\""
array_to_json(anyarray [, pretty_bool])	作为JSON数组返回该数组。PostgreSQL多维数组变成JSON数组中的数组。 如果pretty_bool为真， 则在维度-1元素之间添加换行。	array_to_json('{{1,5},{99,100}}'::int[])	[[1,5],[99,100]]
row_to_json(record [, pretty_bool])	作为JSON对象返回行。如果pretty_bool为 true， 将在级别-1元素之间添加换行符。	row_to_json(row(1,'foo'))	{"f1":1,"f2":"foo"}
json_build_array(VARIADIC "any")	建立一个可能不同类型的JSON数组，由可变参数列表组成。	json_build_array(1,2,'3',4,5)	[1, 2, "3", 4, 5]
json_build_object(VARIADIC "any")	建立一个JSON对象的可变参数列表。按照惯例， 该参数列表由交替的键和值组成。	json_build_object('foo',1,'bar',2)	{"foo": 1, "bar": 2}
json_object(text[])	建立一个JSON对象的文本数组。该数组必须正好有一维偶数个数的成员， 在这种情况下，将它们看做交替的键/值对，或者两维， 这样每个内部数组正好有两个元素，它们被看做是键/值对。	
json_object('{a, 1, b, "def", c, 3.5}')

json_object('{{a, 1},{b, "def"},{c, 3.5}}')

{"a": "1", "b": "def", "c": "3.5"}
json_object(keys text[], values text[])	这种形式的json_object从两个分开的数组中成对的获取键和值。 在所有其他方面，它与一维的形式相同。	json_object('{a, b}', '{1,2}')	{"a": "1", "b": "2"}


函数	返回类型	描述	示例	示例结果
json_array_length(json)

jsonb_array_length(jsonb)

int	返回最外层的JSON数组元素的数量。	json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')	5
json_each(json)

jsonb_each(jsonb)

setof key text, value json

setof key text, value jsonb

扩展最外层的JSON对象为一组键/值对。	select * from json_each('{"a":"foo", "b":"bar"}')	
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
 
json_each_text(json)

jsonb_each_text(jsonb)

setof key text, value text	扩展最外层的JSON对象为一组键/值对。返回值为text类型。	select * from json_each_text('{"a":"foo", "b":"bar"}')	
 key | value
-----+-------
 a   | foo
 b   | bar
 
json_extract_path(from_json json, VARIADIC path_elems text[])

jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])

json

jsonb

返回由path_elems指出的JSON对象 （等效于#>操作符）。	json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')	{"f5":99,"f6":"foo"}
json_extract_path_text(from_json json, VARIADIC path_elems text[])

jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])

text	作为text返回由path_elems 指出的JSON值（等效于#>>操作符）。	json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')	foo
json_object_keys(json)

jsonb_object_keys(jsonb)

setof text	返回JSON对象中最外面的一组键。	json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')	
 json_object_keys
------------------
 f1
 f2
json_populate_record(base anyelement, from_json json)

jsonb_populate_record(base anyelement, from_json jsonb)

anyelement	扩展from_json里的对象到一行， 这行的字段匹配base定义的记录类型（查看下面的注意）。	select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')	
 a | b
---+---
 1 | 2
json_populate_recordset(base anyelement, from_json json)

jsonb_populate_recordset(base anyelement, from_json jsonb)

setof anyelement	扩展from_json里面最外层的对象数组到一个行的集合， 这个集合的字段匹配base定义的记录类型（见下面的注意）。	select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')	
 a | b
---+---
 1 | 2
 3 | 4
 
json_array_elements(json)

jsonb_array_elements(jsonb)

setof json

setof jsonb

扩展一个JSON数组到一组JSON值的集合。	select * from json_array_elements('[1,true, [2,false]]')	
   value
-----------
 1
 true
 [2,false]
json_array_elements_text(json)

jsonb_array_elements_text(jsonb)

setof text	扩展一个JSON数组到一组text值的集合。	select * from json_array_elements_text('["foo", "bar"]')	
      
   value
-----------
 foo
 bar
json_typeof(json)

jsonb_typeof(jsonb)

text	作为文本字符串返回最外面的JSON值的类型。 可能的类型有 Returns the type of the outermost JSON value as a text string. Possible types areobject、array、string、 number、boolean和null。	json_typeof('-123.4')	number
json_to_record(json)

jsonb_to_record(jsonb)

record	从一个JSON对象中建立一个任意的记录（参见下面的注意）。 因为所有函数都返回record，调用者必须用AS 子句明确的定义记录的结构。	select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text)	
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
json_to_recordset(json)

jsonb_to_recordset(jsonb)

setof record	从一个JSON的对象数组中建立一个任意的记录集（参见下面的注意）。 因为所有函数都返回record，调用者必须用AS 子句明确的定义记录的结构。	select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);	
 a |  b
---+-----
 1 | foo
 2 |
```