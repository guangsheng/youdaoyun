#### 基本说明
- 对于JSON字段，gin索引支持@>、?、 ?&和?|四种操作符。
- json 数据类型存储输入文本的精确拷贝，处理函数必须在每个执行上重新解析； 而jsonb数据以分解的二进制格式存储， 这使得它由于添加了转换机制而在输入上稍微慢些，但是在处理上明显更快， 因为不需要重新解析.
- jsonb如果在输入中指定了重复的键，那么只保存最后一个值。
- jsonb拒绝超出PostgreSQL numeric 数据类型范围的数字，而json不拒绝。


#### 操作符
```
操作符	右操作数的类型	描述	示例
@>	jsonb	左侧的JSON值包含右侧的值吗？	'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb
<@	jsonb	左侧的JSON值包含在右侧的值中吗？	'{"b":2}'::jsonb <@ '{"a":1, "b":2}'::jsonb
?	text	测试一个字符串（作为text值给出） 是否作为一个对象键或者数组元素中顶级的jsonb值出现	'{"a":1, "b":2}'::jsonb ? 'b'
?|	text[]	是否存在任一键/元素字符串？	'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']
?&	text[]	是否所有键/元素字符串都存在？	'["a", "b"]'::jsonb ?& array['a', 'b']

操作符	右操作数的类型	描述	示例	示例结果
->	int	获取JSON数组元素（索引从0开始）	'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2	{"c":"baz"}
->	text	通过key获取JSON对象字段	'{"a": {"b":"foo"}}'::json->'a'	{"b":"foo"}
->>	int	获取JSON数组元素为text	'[1,2,3]'::json->>2	3
->>	text	获取JSON对象字段为text	'{"a":1,"b":2}'::json->>'b'	2
#>	text[]	在指定的路径获取JSON对象	'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}'	{"c": "foo"}
#>>	text[]	在指定的路径获取JSON对象为text	'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'	3
```

#### postgresql10 更新和删除
```
SELECT '{"a":1, "b":2}'::jsonb - 'a';
SELECT '{"name":"francs","age":"31"}'::jsonb ||'{"sex":"male"}'::jsonb;
SELECT '{"name": "James", "contact": {"phone": "01234 567890", "fax": "01987 543210"}}'::jsonb #- '{contact,fax}'::text[];
SELECT '{"name": "James", "aliases": ["Jamie","The Jamester","J Man"]}'::jsonb #- '{aliases,1}'::text[];
SELECT '{"name":"francs","age":"31"}'::jsonb ||'{"age":"32"}'::jsonb;
```

```
postgres_mon=# SELECT '{"a":1, "b":2}'::jsonb - 'a';
 ?column?
----------
 {"b": 2}
(1 row)

postgres_mon=# SELECT * FROM json_each('{"a":"foo", "b":"bar"}');
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
(2 rows)

postgres_mon=# SELECT '{"name":"francs","age":"31"}'::jsonb ||'{"sex":"male"}'::jsonb;
                    ?column?
------------------------------------------------
 {"age": "31", "sex": "male", "name": "francs"}
(1 row)

postgres_mon=# SELECT '{"name": "James", "contact": {"phone": "01234 567890", "fax": "01987 543210"}}'::jsonb #- '{contact,fax}'::text[];
                        ?column?
---------------------------------------------------------
 {"name": "James", "contact": {"phone": "01234 567890"}}
(1 row)

postgres_mon=#
postgres_mon=# SELECT '{"name": "James", "aliases": ["Jamie","The Jamester","J Man"]}'::jsonb #- '{aliases,1}'::text[];
                     ?column?
--------------------------------------------------
 {"name": "James", "aliases": ["Jamie", "J Man"]}
(1 row)

postgres_mon=# SELECT '{"name":"francs","age":"31"}'::jsonb ||'{"age":"32"}'::jsonb;
            ?column?
---------------------------------
 {"age": "32", "name": "francs"}
(1 row)

postgres_mon=#
```

#### 一些细节
```
bike=> SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;
 ?column?
----------
 t
(1 row)

bike=> SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;
 ?column?
----------
 f
(1 row)

bike=> SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;
 ?column?
----------
 t
(1 row)

---例外
bike=> SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;
 ?column?
----------
 t
(1 row)

bike=>
```

#### 函数
```
函数	描述	示例	示例结果
to_json(anyelement)	作为JSON返回该值。数组和复合被转换（递归的）成数组和对象；另外， 如果有一个转换从该类型到json，则将使用该转换函数执行转换； 否则，产生JSON标量值。对于任意标量类型，除了数字、布尔或空值， 将使用该文本表示，适当的引用和逃逸，使其是一个有效的JSON字符串。	to_json('Fred said "Hi."'::text)	"Fred said \"Hi.\""
array_to_json(anyarray [, pretty_bool])	作为JSON数组返回该数组。PostgreSQL多维数组变成JSON数组中的数组。 如果pretty_bool为真， 则在维度-1元素之间添加换行。	array_to_json('{{1,5},{99,100}}'::int[])	[[1,5],[99,100]]
row_to_json(record [, pretty_bool])	作为JSON对象返回行。如果pretty_bool为 true， 将在级别-1元素之间添加换行符。	row_to_json(row(1,'foo'))	{"f1":1,"f2":"foo"}
json_build_array(VARIADIC "any")	建立一个可能不同类型的JSON数组，由可变参数列表组成。	json_build_array(1,2,'3',4,5)	[1, 2, "3", 4, 5]
json_build_object(VARIADIC "any")	建立一个JSON对象的可变参数列表。按照惯例， 该参数列表由交替的键和值组成。	json_build_object('foo',1,'bar',2)	{"foo": 1, "bar": 2}
json_object(text[])	建立一个JSON对象的文本数组。该数组必须正好有一维偶数个数的成员， 在这种情况下，将它们看做交替的键/值对，或者两维， 这样每个内部数组正好有两个元素，它们被看做是键/值对。	
json_object('{a, 1, b, "def", c, 3.5}')

json_object('{{a, 1},{b, "def"},{c, 3.5}}')

{"a": "1", "b": "def", "c": "3.5"}
json_object(keys text[], values text[])	这种形式的json_object从两个分开的数组中成对的获取键和值。 在所有其他方面，它与一维的形式相同。	json_object('{a, b}', '{1,2}')	{"a": "1", "b": "2"}


函数	返回类型	描述	示例	示例结果
json_array_length(json)

jsonb_array_length(jsonb)

int	返回最外层的JSON数组元素的数量。	json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')	5
json_each(json)

jsonb_each(jsonb)

setof key text, value json

setof key text, value jsonb

扩展最外层的JSON对象为一组键/值对。	select * from json_each('{"a":"foo", "b":"bar"}')	
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
 
json_each_text(json)

jsonb_each_text(jsonb)

setof key text, value text	扩展最外层的JSON对象为一组键/值对。返回值为text类型。	select * from json_each_text('{"a":"foo", "b":"bar"}')	
 key | value
-----+-------
 a   | foo
 b   | bar
 
json_extract_path(from_json json, VARIADIC path_elems text[])

jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])

json

jsonb

返回由path_elems指出的JSON对象 （等效于#>操作符）。	json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')	{"f5":99,"f6":"foo"}
json_extract_path_text(from_json json, VARIADIC path_elems text[])

jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])

text	作为text返回由path_elems 指出的JSON值（等效于#>>操作符）。	json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')	foo
json_object_keys(json)

jsonb_object_keys(jsonb)

setof text	返回JSON对象中最外面的一组键。	json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')	
 json_object_keys
------------------
 f1
 f2
json_populate_record(base anyelement, from_json json)

jsonb_populate_record(base anyelement, from_json jsonb)

anyelement	扩展from_json里的对象到一行， 这行的字段匹配base定义的记录类型（查看下面的注意）。	select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')	
 a | b
---+---
 1 | 2
json_populate_recordset(base anyelement, from_json json)

jsonb_populate_recordset(base anyelement, from_json jsonb)

setof anyelement	扩展from_json里面最外层的对象数组到一个行的集合， 这个集合的字段匹配base定义的记录类型（见下面的注意）。	select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')	
 a | b
---+---
 1 | 2
 3 | 4
 
json_array_elements(json)

jsonb_array_elements(jsonb)

setof json

setof jsonb

扩展一个JSON数组到一组JSON值的集合。	select * from json_array_elements('[1,true, [2,false]]')	
   value
-----------
 1
 true
 [2,false]
json_array_elements_text(json)

jsonb_array_elements_text(jsonb)

setof text	扩展一个JSON数组到一组text值的集合。	select * from json_array_elements_text('["foo", "bar"]')	
      
   value
-----------
 foo
 bar
json_typeof(json)

jsonb_typeof(jsonb)

text	作为文本字符串返回最外面的JSON值的类型。 可能的类型有 Returns the type of the outermost JSON value as a text string. Possible types areobject、array、string、 number、boolean和null。	json_typeof('-123.4')	number
json_to_record(json)

jsonb_to_record(jsonb)

record	从一个JSON对象中建立一个任意的记录（参见下面的注意）。 因为所有函数都返回record，调用者必须用AS 子句明确的定义记录的结构。	select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text)	
 a |    b    | d
---+---------+---
 1 | [1,2,3] |
json_to_recordset(json)

jsonb_to_recordset(jsonb)

setof record	从一个JSON的对象数组中建立一个任意的记录集（参见下面的注意）。 因为所有函数都返回record，调用者必须用AS 子句明确的定义记录的结构。	select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);	
 a |  b
---+-----
 1 | foo
 2 |
```


## 转自 https://raw.githubusercontent.com/digoal/blog/master/201807/20180731_01.md
## PostgreSQL json 索引实践 - 检索(存在、包含、等值、范围等)加速    
                                                           
### 作者                                                           
digoal                                                           
                                                           
### 日期                                                           
2018-07-31                                                         
                                                           
### 标签                                                           
PostgreSQL , json , gin , rum     
                                                           
----                                                           
                                                           
## 背景    
用户在使用JSON类型时，常见的一些JSON搜索包括：  
  
### 1、存在，JSON中是否存在某个KEY，某些KEY，某些KEY的任意一个  
  
存在某个KEY(TOP LEVEL)  
  
```  
'{"a":1, "b":2}'::jsonb ? 'b'  
```  
  
存在所有KEY  
  
```  
'{"a":1, "b":2, "c":3}'::jsonb ?& array['b', 'c']  
```  
  
存在任意KEY、元素  
  
```  
'["a", "b"]'::jsonb ?| array['a', 'b']  
```  
  
### 2、等值，JSON中是否存在指定的key:value对（支持嵌套JSON）  
  
```  
'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb  
```  
  
### 3、包含，JSON中某个路径下的VALUE（数组）中，是否包含指定的所有元素。  
  
```  
postgres=# select jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}' @> '{"b":{"c":[2,3]}}';  
 ?column?   
----------  
 t  
(1 row)  
```  
  
### 4、相交，JSON中某个路径下的VALUE（数组）中，是否包含指定的任意元素。  
  
```  
postgres=# select jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}' @> '{"b":{"c":[2]}}'   
or  
jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}' @> '{"b":{"c":[3]}}'  
;  
  
 ?column?   
----------  
 t  
(1 row)  
```  
  
或(注意1,2,3需要双引号，作为text类型存储，因为操作符```?|  ?&```暂时只支持了text[]，如果是numeric匹配不上)  
  
```  
postgres=# select jsonb '{"a":1, "b": {"c":["1","2","3"], "d":["k","y","z"]}, "d":"kbc"}' -> 'b' -> 'c' ?& array['2','3','4'] ;  
 ?column?   
----------  
 f  
(1 row)  
  
postgres=# select jsonb '{"a":1, "b": {"c":["1","2","3"], "d":["k","y","z"]}, "d":"kbc"}' -> 'b' -> 'c' ?| array['2','3','4'] ;  
 ?column?   
----------  
 t  
(1 row)  
```  
  
### 5、范围查找，JSON中某个路径下的VALUE，是否落在某个范围内。  
  
```  
(js ->> 'key1' )::numeric between xx and xx  
  
(js ->> 'key2' )::numeric between xx and xx  
```  
  
这些操作如何加速，或者如何使用索引加速？  
  
## 一、json 索引支持  
GIN的两个OPS，分别支持JSON：  
  
```  
The default GIN operator class for jsonb supports queries with top-level key-exists operators ?, ?& and ?| operators and path/value-exists operator @>.  
  
The non-default GIN operator class jsonb_path_ops supports indexing the @> operator only.  
```  
  
### 1、支持 ```@>``` 操作符的索引如下（jsonb_path_ops只支持```@>```操作符，但是效率高）  
  
```  
postgres=# create table tbl(id int, js jsonb);  
CREATE TABLE  
postgres=# create index idx_tbl_1 on tbl using gin (js jsonb_path_ops);  
CREATE INDEX  
```  
  
### 2、支持除范围查询以外的所有查询的索引如下  
  
```  
postgres=# create table tbl(id int, js jsonb);  
CREATE TABLE  
postgres=# create index idx_tbl_1 on tbl using gin (js);  -- 使用默认ops即可  
CREATE INDEX  
```  
  
## 二、JSON KEY VALUE值范围查询加速  
某些使用，需要对VALUE使用范围查询，比如时间(如果要建索引，请使用numeric表示，否则需要自定义immutable函数)，数值都有这些需求。  
  
通常的做法，把范围查询的类型提取出来，创建btree表达式索引，如果有任意组合的范围查询，使用gin或rum表达式索引。  
  
例子  
  
```  
create index idx1 on tbl ( ((js->>'k1')::float8) );  
create index idx2 on tbl ( ((js->>'k2')::numeric) );  
...  
create index idxn on tbl ( ((js->>'kn')::float8) );  
```  
  
或  
  
```  
create extension btree_gin;  
create index idx1 on tbl using gin( ((js->>'k1')::float8), ((js->>'k2')::numeric), ... ((js->>'kn')::float8) );  
```  
  
或  
  
```  
create extension rum;  
create index idx1 on tbl using rum( ((js->>'k1')::float8), ((js->>'k2')::numeric), ... ((js->>'kn')::float8) );  
```  
  
或  
  
```  
create or replace function to_timestamp(text) returns timestamp as $$  
  select $1::timestamp;  
$$ language sql strict immutable;  
  
  
create index idx1 on tbl using gin( ((js->>'k1')::float8), to_timestamp(js->>'k2'), ... ((js->>'kn')::float8) );  
或  
create index idx1 on tbl using rum( ((js->>'k1')::float8), to_timestamp(js->>'k2'), ... ((js->>'kn')::float8) );  
```  
  
  
## 三、索引使用例子  
  
  
```  
create table tbl(id int, js jsonb);  
create index idx_tbl_1 on tbl using gin (js jsonb_path_ops);  
create index idx_tbl_2 on tbl using gin (js);  
create index idx_tbl_3 on tbl using rum( ((js->>'k1')::float8), to_timestamp(js->>'k2'), ((js->>'k3')::numeric) );  
  
postgres=# explain select * from tbl where js ? 'a';  
                               QUERY PLAN                                 
------------------------------------------------------------------------  
 Bitmap Heap Scan on tbl  (cost=2.21..3.32 rows=1 width=36)  
   Recheck Cond: (js ? 'a'::text)  
   ->  Bitmap Index Scan on idx_tbl_2  (cost=0.00..2.21 rows=1 width=0)  
         Index Cond: (js ? 'a'::text)  
(4 rows)  
  
postgres=# explain select * from tbl where js @> '{"a":"b"}';  
                               QUERY PLAN                                 
------------------------------------------------------------------------  
 Bitmap Heap Scan on tbl  (cost=2.21..3.32 rows=1 width=36)  
   Recheck Cond: (js @> '{"a": "b"}'::jsonb)  
   ->  Bitmap Index Scan on idx_tbl_1  (cost=0.00..2.21 rows=1 width=0)  
         Index Cond: (js @> '{"a": "b"}'::jsonb)  
(4 rows)  

postgres=# explain select * from tbl where to_timestamp(js->>'k2') between '2018-01-01' and '2018-01-02';
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using idx_tbl_3 on tbl  (cost=5.50..12.22 rows=6 width=36)
   Index Cond: ((to_timestamp((js ->> 'k2'::text)) >= '2018-01-01 00:00:00'::timestamp without time zone) AND (to_timestamp((js ->> 'k2'::text)) <= '2018-01-02 00:00:00'::timestamp without time zone))
(2 rows)

postgres=# explain select * from tbl where to_timestamp(js->>'k2') between '2018-01-01' and '2018-01-02' and ((js->>'k3')::numeric) between 1 and 200;
                                                                                                                                                     QUERY PLAN                                                                              
                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------
 Index Scan using idx_tbl_3 on tbl  (cost=9.90..12.11 rows=1 width=36)
   Index Cond: ((to_timestamp((js ->> 'k2'::text)) >= '2018-01-01 00:00:00'::timestamp without time zone) AND (to_timestamp((js ->> 'k2'::text)) <= '2018-01-02 00:00:00'::timestamp without time zone) AND (((js ->> 'k3'::text))::numeric >
= '1'::numeric) AND (((js ->> 'k3'::text))::numeric <= '200'::numeric))
(2 rows)

  
postgres=# select * from tbl where js @> '{"a": {"b":"c"}}';  
 id | js   
----+----  
(0 rows)  
  
SELECT doc->'site_name' FROM websites  
  WHERE doc->'tags' @> '[{"term":"paris"}, {"term":"food"}]';  
  
postgres=# select jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}';  
                               jsonb                                 
-------------------------------------------------------------------  
 {"a": 1, "b": {"c": [1, 2, 3], "d": ["k", "y", "z"]}, "d": "kbc"}  
(1 row)  
  
postgres=# select jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}' @> '{"b":{"c":[2,3]}}';  
 ?column?   
----------  
 t  
(1 row)  
  
postgres=# select jsonb '{"a":1, "b": {"c":[1,2,3], "d":["k","y","z"]}, "d":"kbc"}' @> '{"b":{"c":[2,4]}}';  
 ?column?   
----------  
 f  
(1 row)  
  
  
postgres=# explain select * from tbl where js @> '{"b":{"c":[2,4]}}';  
                               QUERY PLAN                                 
------------------------------------------------------------------------  
 Bitmap Heap Scan on tbl  (cost=3.31..4.42 rows=1 width=36)  
   Recheck Cond: (js @> '{"b": {"c": [2, 4]}}'::jsonb)  
   ->  Bitmap Index Scan on idx_tbl_1  (cost=0.00..3.31 rows=1 width=0)  
         Index Cond: (js @> '{"b": {"c": [2, 4]}}'::jsonb)  
(4 rows)  
```  
  
  
  
## 参考  
https://www.postgresql.org/docs/devel/static/datatype-json.html  
  
https://www.postgresql.org/docs/devel/static/functions-json.html  
  
[《PostgreSQL 电商业务(任意维度商品圈选应用) - json包range数组的命中优化 - 展开+索引优化》](../201807/20180703_02.md)    
  
[《如何让json里面的value支持索引范围检索》](../201807/20180702_02.md)    
  
[《PostgreSQL 11 preview - jsonb_plpython, jsonb_plperl 插件, PG类型jsonb与pyton,perl程序类型的相互转换》](../201805/20180519_09.md)    
  
[《PostgreSQL 店铺运营实践 - JSON[]数组 内部标签数据等值、范围检索100倍+加速示例 (含，单值+多值列合成)》](../201802/20180208_01.md)    
  
[《PostgreSQL json 任意位置 append 功能实现》](../201801/20180105_01.md)    
  
[《多流实时聚合 - 记录级实时快照 - JSON聚合与json全文检索的功能应用》](../201712/20171209_01.md)    
  
[《HTAP数据库 PostgreSQL 场景与性能测试之 46 - (OLTP) 大json字段的高并发更新》](../201711/20171107_47.md)    
  
[《HTAP数据库 PostgreSQL 场景与性能测试之 32 - (OLTP) 高吞吐数据进出(堆存、行扫、无需索引) - 阅后即焚(JSON + 函数流式计算)》](../201711/20171107_33.md)    
  
[《plpgsql 编程 - JSON数组循环》](../201708/20170802_01.md)    
  
[《JSONB 压缩版本 ZSON》](../201706/20170604_01.md)    
  
[《PostgreSQL 10.0 preview 功能增强 - SQL:2016标准(之SQL/JSON)  Oracle 12c兼容》](../201703/20170313_05.md)    
  
[《PostgreSQL 10.0 preview 功能增强 - JSON 内容全文检索》](../201703/20170312_24.md)    
  
[《如何从PostgreSQL json中提取数组》](../201609/20160910_01.md)    
  
[《PostgreSQL merge json的正确姿势》](../201606/20160614_06.md)    
  
[《PostgreSQL json jsonb 支持的value数据类型，如何构造一个jsonb》](../201509/20150924_03.md)    
  
  
<a rel="nofollow" href="http://info.flagcounter.com/h9V1"  ><img src="http://s03.flagcounter.com/count/h9V1/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_0/flags_0/"  alt="Flag Counter"  border="0"  ></a>  
  