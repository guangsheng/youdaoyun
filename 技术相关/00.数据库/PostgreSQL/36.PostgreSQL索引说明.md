### 语法
```SQL
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] name ] ON table_name [ USING method ]
    ( { column_name | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( storage_parameter = value [, ... ] ) ]
    [ TABLESPACE tablespace_name ]
    [ WHERE predicate ]
```

#### 指定索引排序顺序，用于多字段索引: ```[ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...]```  

- order by + limit: 如果有索引且通过索引可以找出前几行，就不需要列出全部记录后再选择几行了

#### HOT
1. update没有更新索引列  
2. 表块有足够空间容纳update产生的新版本行，即同一update chain上的所有版本必须位于同一个数据块中。  

如果不满足上面两个条件，即使更新的列不包含索引列，索引也会新增一个item用来记录。
##### 说明
>
表t有两个列(id , name)，其中name上有索引 ind_name，现在表有2个数据行，分别称为tuple1和tuple2  
(1, 'a')    
(0, 'b')  
执行update t set id =id+ 1 where name = 'a'  
现在表上有3个数据行  
```
(1, 'a') ---> (2, 'a')  
(0, 'b')
```
而索引ind_name没有改变  
```
('a', tuple1_pos)
('b', tuple2_pos)
```  
>
尽管数据行从(1, 'a')变成了(2, 'a')，但是ind_name的索引项仍然指向(1, 'a')，回表时通过遍历update chain找到(2, 'a')  
这种改进被称为HOT(heap only tuple)

#### using method
+ B-Tree
+ HASH
+ GiST
+ SP-GiST
+ GIN
+ BRIN

#### B-Tree
- 默认
- 适合处理能够按顺序存储的数据之上的等于和范围查询
- B-tree支持排序的输出（也就是不需要在查询出结果集后再排序）
- 支持前导模糊查询和忽略大小写前导模糊查询（ILIKE）

#### HASH
- 只适合于等于比较
- 没有记录WAL日志，因此数据库崩溃存在丢失风险且流复制有问题
- 不推荐使用

#### GiST
- 通用的搜索树(Generalized Search Tree)。 它是一种平衡树结构的访问方法，在系统中作为一个基本模版，可以使用它实现任意索引模式。 B-trees, R-trees和许多其它的索引模式都可以用GiST实现
- 不是单独一种索引类型，而是一种架构
- 支持对几何操作（平移，伸缩，旋转，交点，交面，最近点，间距，重叠，相交，水平，垂直，包含等）索引
- 找出距离给出目标点最近的十个地点: ```SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;```
- PG标准发布件中的GiST索引支持的操作

```
<<			是否严格在左？
&<			是否没有延伸到右边？
&>			是否没有延伸到左边？
>>			是否严格在右？
<<|			严格在下？
&<|			没有延伸到上面?	
|&>			没有延伸到下面?	
|>>			严格在上？
@>			包含?
<@			包含或在...上?	
~=			与...相同?	
&&			重叠？（有一个共同点为真）
```

#### SP-Gist
- SP-GiST是空间分割的(Space-Partitioned)GiST的省略语。 SP-GiST支持分区的搜索树，这有助于开发四叉树，KD树，基数树(radix tree)等范围广泛的不同的非平衡数据结构。 这些结构的共通特征是它们反复地把搜索空间划分成大小不必相等的分区。能很好的匹配分区规则的查询会非常快。
- 和GiST一样，SP-GiST允许伴随相应访问方法的定制数据类型由该数据类型领域里的专家而不是数据库专家来开发。

#### GIN
- GIN 索引是反转索引，它可以处理包含多个键的值(比如数组)
- GIN 支持用户定义的索引策略，可以使用 GIN 索引的操作符根据索引策略的不同而不同
- jsonb缺省的GIN操作符类支持使用```@>、?、 ?&和?|```操作符查询
- PG标准发布件中的GIN索引支持的操作
```
<@		被包含于
@>		包含
=		等于（数组比较）
&&		重叠（有共同元素）
```

#### BRIN

### 操作符类和操作符族
#### 说明
拥有操作符类的主要原因是： 对于某些数据类型，可能存在多个有意义的索引行为。例如，我们可能想排序两个复数， 既可能通过绝对值，也可能通过实部。我们可以通过为该数据类型定义两个操作符类， 然后在建立索引时选择合适的那个。操作符类决定了基本的排序方式（这个方式可以通过添加排序选项来修改： COLLATE, ASC/DESC 和/或 NULLS FIRST/NULLS LAST）。  

#### 举例
```text_pattern_ops,varchar_pattern_ops和bpchar_pattern_ops```操作符类分别支持在text, varchar和char类型上的 B-tree 索引。 他们与初始的操作符类的区别是数值是严格地逐个字节比较的，而不是根据区域相关的排序规则进行比较。   

```CREATE INDEX test_index ON test_table (col varchar_pattern_ops);```  

请注意，如果你希望包含普通<,<=, >,或 >=比较的查询使用索引，那么你还应该创建一个使用缺省操作符类的索引。 这样的查询不能使用xxx_pattern_ops操作符类。 （不过普通相等比较可以使用这个操作符类。）在同一个字段上创建多个使用不同操作符类的索引是可能的。 

#### 查询显示所有定义的操作符族和每个族内的所有操作符
```
SELECT am.amname AS index_method,
       opf.opfname AS opfamily_name,
       amop.amopopr::regoperator AS opfamily_operator
    FROM pg_am am, pg_opfamily opf, pg_amop amop
    WHERE opf.opfmethod = am.oid AND
          amop.amopfamily = opf.oid
    ORDER BY index_method, opfamily_name, opfamily_operator;
```

### 综合
- B-tree, GiST, GIN支持多字段索引
- 表达式索引
- 部分索引（部分唯一索引）
- 