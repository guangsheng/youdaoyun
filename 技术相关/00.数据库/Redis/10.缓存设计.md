redis是key-value内存数据库，操作在微妙级别。通常用作缓存，提升性能。  

### 缓存设计
- 缓存更新策略
- 缓存粒度控制
- 缓存穿透优化
- 无底洞问题优化
- 雪崩问题优化

> 对数据的一致性要求决定了应该选择什么样的更新策略。  

> 粒度设计是应用应该重点考虑的方面，记录value过大，不仅影响内存占用，还会影响磁盘IO，网络IO，CPU消耗等等。而如果value过小，又可能需要多次读取才能获取某个信息。  

> 什么是穿透？ 缓存穿透指的是查询一个根本不存在的数据，缓存层和存储层都不会命中，这种现象会导致每次数据请求都要到存储层查询，失去了使用缓存保护后端存储的作用。  

> 什么是无底洞？ 通俗的说，就是不是越多越好。投入越多不一定产出越多，更多的节点不代表更高的性能，就是无底洞。 为什么会出现这种现象？ 在分布式场景中，更多的节点加入后，一次批量操作会涉及更多的节点，也意味着更多的网络操作，耗时就会变多。而且网络连接数变多，对节点的性能也是有影响的。并且以redis cluster为例，节点变多，redis节点间通信的消息量也会变多，占用的带宽也会越多。

> 什么是雪崩： 缓存层由于某种原因不能提供服务，所有请求都到达存储层的现象。可能会导致级联宕机。

### 更新策略
缓存层和存储层的数据存在着一定时间窗口的不一致性，时间窗口和更新策略有关。  

#### 常见的更新策略有：  
- LRU/LFU/FIFO算法剔除： 比如redis提供了两个参数maxmemory和maxmemory-policy，运行配置内存不够时使用什么算法淘汰key。  
- 超时剔除： 比如redis提供了key过期机制。同时过期容易引起雪崩。  
- 主动更新： 应用方实现，真实数据更新后，立即更新缓存数据。  

#### 最佳实践：  
低一致性业务可以使用算法剔除方法。  
高一致性业务建议结合使用超时剔除和主动更新，超时剔除主要用来保证主动更新出错后，有补救的机会。  


### 穿透优化的几种方法
- 缓存空对象： 空对象代表对象在存储层也不存在。但同时会带来key太多，占用内存过多的问题。
- 布隆过滤器拦截： 基本原理是使用布隆过滤器将存在的key缓存起来，如果在布隆过滤器中找不到这个key，就说明这个key不存在。适用于数据命中不高、数据相对固定的场景。

那么如何判断是否出现了穿透问题呢？  
1. 在存储层获取sql执行次数，看是否执行次数是否出现异常了。但更好的办法是  
2. 在应用端程序中统计调用总次数、缓存层命中数、存储层命中数  

### 无底洞优化的方法
总体思路就是如何降低网络操作消耗。
- 串行IO： 就是把批量操作中同一节点的数据一次性取出，把时间优化为node次网络时间+n次命令时间，而不是n次网络时间+n次命令时间，可以理解为先排序后查询。例如1，3两条数据在A节点，2在B节点，应该先从A节点取出1，3，再从B节点取出2；而不是第一条数据从A节点取出，第二条数据从B节点却出，第三条数据再从A节点取出。
- 并行IO：就是把命令归并后，将命令执行这步并行执行。将时间优化为 max_slow(node网络时间) + n次命令时间

- hash_tag: 将可能批量查询的数据放到同一个节点，但是这样处理不好，极容易出现数据倾斜的问题。

### 雪崩问题
对于redis故障无法提供服务的场景，要考虑提供redis的可靠性（比如搭建高可用环境）和业务分流降级的机制（比如查不到A就查B）的方式来提供可靠性和可用性。  

同时要避免缓存同时失效，大量key同时过期场景的出现并做保护：如使用锁控制同时只会有一个线程从存储层查询某个key的信息。