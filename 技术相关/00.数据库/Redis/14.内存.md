### 查看当前redis内存使用情况
```
127.0.0.1:6379> info memory
# Memory
used_memory:1008336
used_memory_human:984.70K
used_memory_rss:1732608
used_memory_rss_human:1.65M
used_memory_peak:1008336
used_memory_peak_human:984.70K
total_system_memory:8589934592
total_system_memory_human:8.00G
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
mem_fragmentation_ratio:1.72
mem_allocator:libc
127.0.0.1:6379>
```

### Redis内存
- Redis内存消耗主要包括：自身内存消耗+对象内存+缓冲内存+内存碎片
- 对象内存： sizeof(key)+sizeof(value)  不要忽略key的内存占用
- 缓冲内存： 客户端缓冲、复制积压缓冲、AOF缓冲区

#### 缓冲内存
##### 客户端缓冲
包括输入缓冲和输出缓冲，输入缓冲无法控制，最大空间为1GB，输出缓冲可以通过```client-output-buffer-limit normal|slave|pubsub maxsize minsize time```控制。  
客户端分为：普通客户端、从客户端和订阅客户端

##### 复制积压缓冲区： 使用参数repl-backlog-size控制
##### AOF缓冲区用户无法控制，通常很小。

#### 内存管理
- 动态调整内存上限```config set maxmemory```
- 内存达到maxmemory上限时会触发内存溢出控制策略（maxmemory-policy)。

##### redis删除过期建（设置了过期属性）的方法
- 惰性删除： 客户端读取已经过期的键时，执行删除操作并返回空。
- 定时任务删除：默认每秒运行10次，根据键的过期比例、使用快慢两种速率模式回收键。

##### 内存溢出控制策略
- noeviction: 默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息（error, OOM command...）
- volatile-lru: 根据LRU算法删除过期键，直到腾出足够空间。
- allkeys-lru: 根据LRU算法删除所有键，直到腾出足够空间。
- allkeys-random: 随机删除所有键，直到腾出足够空间。
- volatile-random: 随机删除过期键，直到腾出足够空间。
- volatile-ttl: 根据键值对象的ttl属性删除最近将要过期的数据，如果没有，回到noeviction策略

#### 内存优化
##### 优化内存首先要了解Redis中的对象结构：  
```
type redisObject:
    type:4                #对象数据类型：string, hash, list, set ,zset
    encoding:4            #内部编码类型，可以执行object encoding key获取编码类型
    lru:REDIS_LRU_BITS    #LRU计数时针,可以执行object idletime key在不更新lru字段情况下查看当前键的空闲时间
    int refcount          #引用计数器
    void *ptr             #数据指针（如果是整数，直接存储数据，否则表示指向数据的指针）
```

Redis3.0之后值对象是字符串且长度小于等于39字节的数据，内部编码为embstr类型，字符串SDS（simple dynamic string）和redisObject一起分配，从而减少内存操作。

##### Redis中的字符串结构
```
SDS(simple dynamic string）
   int len;
   int free;
   char buf[]
```

- O(1)获取字符串长度
- 空间预分配，降低内存再分配次数
- 字符串缩减后空间不释放
- 追加操作需要内存重新分配，会造成内存碎片。
- buf扩大策略：小于1M，每次预分配一倍空间，超过1M，每次预分配1M

##### 数据结构
- intset数据结构插入命令复杂度为O(n), 查询命令复杂度为O(log(n))
- ziplist当长度超过2^16-2时，获取长度的复杂度从O(1)变为O(n)
- ziplist在内部表现为数据紧凑排列的一块连续内存数组，新增删除操作涉及内存的重新分配或释放

#### 编码优化
类型   |编码方式   |数据结构              |决定条件
------|----------|--------------------|----
string|raw       |动态字符串编码
      |embstr    |优化内存分配的字符串编码
      |int       |整数编码
hash  |hashtable |散列表编码   |！ziplist条件
      |ziplist   |压缩列表编码 | value最大空间<= hash-max-ziplist-value && filed个数 <= hash-max-ziplist-entries
list  |linkedlist|双向链表变慢 | ！ziplist条件
      |ziplist   |压缩列表编码 | value最大空间<= list-max-ziplist-value && 链表程度 <= list-max-ziplist-entries
      |quicklist |快速链表编码 | 3.2新提供，废弃了上面的两个配置，使用新的配置list-max-ziplist-size和list-compress-depth
set   |hashtable |散列表编码  | ! intset条件
      |intset    |整数集合编码 | 元素必须为整数且集合长度<=set-max-intset-value
zset  |skiplist  |跳跃表编码  | ！ziplist条件
      |ziplist   |压缩列表编码 | value最大空间<=zset-max-ziplist-value && 有序集合长度 <= zip-max-ziplist-entires

#### 一些经验
- 正常的碎片率在1.03左右
- 建议设置maxmemory
- 频繁执行内存回收的成本很高
- 在条件允许情况下，建议字符串长度小于39字节
- 在不影响描述的情况下，key越短越好
- 如果value可以压缩存储，那么可以考虑压缩存储，压缩算法可以在CPU和压缩比例直接折中选择。
- 在某些情况下，把json字符串改为多个key-value对的方式存储会降低内存消耗。
- 通过修改便饭方式降低内存占用，同时会增加命令执行耗时。

##### 利用hash结构降低键数量
- 将键映射到一组hash对象中，比如100万个键可以映射到1000个hash中，每个hash保存1000个元素。
- hash的filed可用于记录原始的key信息
- hash的value保存原值值对象，确保不要超过hash-max-ziplist-value限制。

数据量|key大小-B|value大小-B|String-MB|hash-ziplist-MB|内存降低比例|string-set耗时（微秒）|hash set-耗时（微妙）
----|---|---|-------|-------|-----|----|----
200w|20 |512|1392.64|1000.97|28.1%|2.13|21.28
200w|20 |100|382.99 |211.88 |44.6%|1.30|14.92
200w|20 |20 |246.40 |55.63  |77.4%|1.10|13.21