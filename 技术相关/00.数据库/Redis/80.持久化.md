### Redis启动流程
- 开启AOF？
	- yes
		- 存在AOF?
			- yes 
				- 加载AOF启动
			- no
				- 存在RDB
					- yes 加载RDB启动
					- no  成功 
	- no 
		- 存在RDB？
			-  yes 加载RDB启动
			-  no  成功

### RDB
- RDB持久化就是把当前进程数据生成快照保存到硬盘的过程。
- RDB文件保存在dir配置的制定的目录下
- 可以通过执行```config set dir newDir```和```config set dbfilename newFileName```修改RDB文件保存目录。
- RDB是一个紧凑压缩的二进制文件。
- 没有办法做到实时持久化。
- 恢复速度远远快于AOF。
- 新旧版本可能不兼容。

#### 触发方式
- 手动触发: ```save```和```bgsave```命令
- 自动触发
	- ```save m n```: m秒内数据集存在n此修改时，自动触发bgsave
	- **从节点执行全量复制操作，主节点会自动执行bgsave命令生成RDB文件并发送给从节点**
	- 执行debug reload命令重新加载redis时。
	- 默认情况下执行shutdown命令，如果没有开启AOF则在自动执行bgsave

#### bgsave
save命令会阻塞当前Redis服务器，直到持久化完成，已经废弃。
##### bgsave执行过程
- 检查是否满足启动条件（是否存在正在执行的子进程）
- 主进程执行fork命令创建子进程.  **这个阶段会发生阻塞**
- 子进程创建RDB文件。
- 完成后给主进程发送信号

### AOF
append only file持久化，以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。

#### 工作流程
1. 写入命令追加到aof_buf（缓冲区）中
2. 根据对应策略做缓冲区向硬盘的同步操作。
3. 定期对AOF文件重写，达到压缩的目的。
4. 重启时，加载AOF文件进行数据恢复。

#### 使用说明
- 相关配置
	- appendonly :默认关闭，打开需要配置为yes
	- appendfilename: 默认文件名是appendonly.aof，保存路径用的是dir指定的目录，和RDB用的同一个目录
- AOF写入的内容是文本协议格式的

#### 缓冲区同步文件策略(fsync)
- always
- everysec
- no

#### 重写说明
- 存在的意义：AOF的方式决定了，随着命令不断执行，AOF文件会越来越大，所以需要重写来压缩文件体积。
- 重写使用进程内数据直接生成，只保留了最终数据的写入命令，所以文件会比较小。
- 重写流程类似于RDB持久化，但需要解决一个问题，打快照成功到文件重写完成这段时间的命令也需要保留，但是并不能使用原有的缓冲区，因为重写并不一定成功。因此会新生成一个缓冲区，在这个过程中，命令会同时写入新缓冲区和原有缓冲区。
- 为了防止单词刷盘数据过多造成硬盘阻塞，提供了配置```aof-rewrite-incremental-fsync```控制每次写入硬盘的数据量，默认为32MB。

##### 重写触发策略
- 手动触发 ```bgrewriteaof```
- 自动触发
	- auto-aof-rewrite-min-size :  运行AOF重写时文件最小体积，默认64MB
	- auto-aof-rewrite-percentage : 当前AOF文件空间(aof_current_size)和上一次重写后AOF文件空间(aof_base_size)的比值 
	- 自动触发时机 = aof_current_size > audo-aof-rewrite-min-size && (aof_current_size - aof_base_size) / aof_base_size >= auto-aof-rewrite-percentage)

#### 小技巧
- 执行info stats命令查看latest_for_usec可以获知最近一次fork的耗时，单位是微妙。
- 执行lastsave命令可以获取最后一次生成RDB的时间。

#### 注意事项
- 10GB的Redis进程，fork需要复制大约20MB的内存页表。
- 正常情况fork耗时应该是每GB消耗20ms左右。
- 数据分批写入文件是CPU密集操作，通常利用率能到单核90%。
- AOF即使是每秒调用一次fsync，也要考虑到I/O导致的阻塞。
- 多Redis实例部署在同一个机器上，要考虑I/O的竞争。