### Linux配置优化注意事项
#### 1. vm.overcommit_memory
申请内存后，并不会马上使用内存，这种技术叫做voercommit。redis建议设置为1，表示内核允许超量使用内存直到用完为止。  

#### 2.swappiness
决定操作系统使用swap的倾向程度，取值范围0-100，值越低，表示操作系统更加倾向于使用物理内存。0和1的含义在linux3.4和3.5是不一致的，在实际配置时需要注意。

#### 3.THP
Transparent Huge Page，支持大页内存（2MB）分配，开启后每个内存页的大小会从4KB变为2MB，对于redie小内存较多，且OS有写时复制技术，会导致性能下降，内存消耗变多，所以redis建议关闭这个选项。  

#### 4.NTP
服务器环境时间要保持一致，特别是分布式系统。

#### 5.unlimit
需要根据实际情况修改可以打开的文件句柄数。

#### 6.tcp-backlog
redis建议配置为511  

理解backlog：  
To understand the backlog argument, we must realize that for a given listening socket, the kernel maintains two queues :  
要明白backlog参数的含义，我们必须明白对于一个listening socket，kernel维护者两个队列：

1.An incomplete connection queue, which contains an entry for each SYN that has arrived from a client for which the server is awaiting completion of the TCP three-way handshake. These sockets are in the SYN_RCVD state .  
1.一个未完成连接的队列，此队列维护着那些已收到了客户端SYN分节信息，等待完成三路握手的连接，socket的状态是SYN_RCVD

2.A completed connection queue, which contains an entry for each client with whom the TCP three-way handshake has completed. These sockets are in the ESTABLISHED state   
2.一个已完成的连接的队列，此队列包含了那些已经完成三路握手的连接，socket的状态是ESTABLISHED

The backlog argument to the listen function has historically specified the maximum value for the sum of both queues.  
backlog参数历史上被定义为上面两个队列的大小之和

### bigkey和热点key
#### bigkey
bigkey指的是value所占内存比较大的的key。一般认为超过10KB就是bigkey。  
判断一个key是否bigkey，可以执行debug key查看serializedlength属性。serializedlength代表的不是真实的字节大小，它返回的是RDB编码序列化后的长度，会偏小。  

如何查找bigkey：

```
redis-cli --bigkeys

scan + debug object key
```

如何删除bigkey：删除bigkey通常来说会阻塞Redis服务，对于字符串类型，可以直接使用del命令删除(参考耗时：10MB1ms），对于其他集合类型，建议每次只删除该key的value中的一部分。  

删除耗时参考(ms)：  

key类型|10万（8Byte）|100万（8Byte）|10万（128Byte）|100万（128Byte）
---|---|---|---|---
hash|51|950|96|2000
list|23|134|23|266
set|44|873|73|1319
sorted set|51|845|59|969

#### 寻找热点key
Facebook开源的redis-faina(https://github.com/facebookarchive/redis-faina)


### 一些经验
- 如果只有几百或几千OPS的实例就接近CPU饱和时不正常的。
- fork和AOF刷盘都可能导致阻塞。  
- 开启了持久化或参与复制的主节点不建议绑定CPU，因为fork出的子进程会与主进程竞争CPU。
- Redis不会主动关闭长时间闲置连接或检查关闭无效的TCP连接。
- 系统对特定端口的连接使用backlog队列保存，Redis默认511.这个队列是可能溢出的（通过```netstat -s|grep overflowed```命令可以查看溢出情况）。
- monitor命令可能导致内存暴涨，因为其输出缓冲区占用的可能较多。